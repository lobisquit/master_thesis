# -*- mode: Org; -*-

#+STARTUP: indent
#+OPTIONS: toc:nil

In order for this protocols to work, each page request has to have

- a request ID unique for the user
- a sequence number P, unique in the session
- a sequence max number L, constant for the session
- routing information (path)
- size
- transmission time, in order to estimate RTT
- a type, for distinguishing between page requests, ACKs, ...

We suppose a on-off user activity process, with exponential off times, 10s mean.

* TCP like protocol
Description of a Go-Back-N ARQ protocol that is similar enough to TCP for our
purposes.

Note that at any time, receiving a request with ID different from the current
one (if any) resets the server to IDLE and the last request is processed.

#+BEGIN_SRC plantuml :file figures/tcp_server_side.png :noweb yes
  <<plantuml_skin>>
  skinparam defaultTextAlignment center
  hide empty description
  state INIT : # set A = -1 \l# set B = 0 \l# estimate RTT based on request packet
  state IDLE #f6ff9b

  state TRANSMIT {
    state TRANSMIT_DECIDE : B < A + N + 1?
    state TRANSMIT_PACKET : # transmit packet B + 1 \l# set B = B + 1
    state WAIT
    state "TRASMIT_REPEAT" as SCHEDULE_RETX : set B = A
  }

  state RECEIVE {
    state "P = L?" as CHECK_FINISH
    state RECEIVE_UPDATE : # compute Round Trip Time \lof the last ACKed packets \l# set A = max{A, P}\l# set B= max{B, A}
  }
  state "IDLE" as FINISH #f6ff9b


   IDLE -> INIT : Page request \n with window size N
   INIT --> TRANSMIT_DECIDE

   TRANSMIT_DECIDE --> WAIT : NO
   TRANSMIT_DECIDE -> TRANSMIT_PACKET : YES
   TRANSMIT_PACKET -> TRANSMIT_DECIDE : Timeout of RTT/2

  SCHEDULE_RETX -> TRANSMIT_DECIDE

  WAIT -> SCHEDULE_RETX : Timeout of t<sub>0</sub>
  TRANSMIT --> RECEIVE_UPDATE : ACK(P) received

  RECEIVE_UPDATE -> CHECK_FINISH

  CHECK_FINISH --> FINISH : YES
  CHECK_FINISH -> TRANSMIT_DECIDE: NO

  legend
  ,* A is the ID of the last packet known to be received by the user
  ,* B is the ID of the last packet sent by the server
  ,* L is the ID of the last packet of current page request
  ,* ρ is the current (estimated) throughput of the connection
  ,* t<sub>0</sub> is a multiple of the estimated Round Trip Time
  end legend
#+END_SRC

#+RESULTS:
[[file:figures/tcp_server_side.png]]

#+BEGIN_SRC plantuml :file figures/tcp_client_side.png :noweb yes
  <<plantuml_skin>>

  skinparam defaultTextAlignment center
  hide empty description

  state REQUEST {
    state REQUEST_INIT : # pick unique session id \l# initialize arrived array
    state REQUEST_WAIT : Transmit page request
  }
  state IDLE #f6ff9b
  state RECEIVE {
    state DATA_UPDATE : # update channel metrics\l# set arrived(P) = True\l# set K=argmin{arrived(i)=False}
    state DATA_ACK : Send ACK(K)
    state "K = L?" as CHECK_FINISH
    state DATA_WAIT
  }
  state "IDLE" as FINISH #f6ff9b
  state EVALUATE : Compute QoS and QoE
  state UNUSABLE : Mark service as unusable

  IDLE --> REQUEST_INIT : User requests a page
  IDLE -> ACK_L : Packet P of L arrives
  ACK_L -> IDLE : \n

  REQUEST --> UNUSABLE : N × t<sub>0</sub>
  REQUEST_INIT -> REQUEST_WAIT

  REQUEST_WAIT -> REQUEST_WAIT : t<sub>0</sub>
  REQUEST_WAIT --> DATA_UPDATE : Packet P of L arrives

  DATA_UPDATE -> DATA_ACK

  DATA_ACK --> CHECK_FINISH

  DATA_WAIT --> UNUSABLE : N × t<sub>0</sub>
  DATA_WAIT -up-> DATA_UPDATE : Packet P of L arrives
  DATA_WAIT -left> DATA_ACK : RTT

  CHECK_FINISH --> EVALUATE : YES
  CHECK_FINISH -> DATA_WAIT : NO

  UNUSABLE -left> EVALUATE

  EVALUATE --> FINISH

  legend
  ,* t<sub>0</sub> is a multiple of the supposed Round Trip Time of the connection
  ,* each data packet contains its ID, P, and the ID of the last one, L
  end legend

#+END_SRC

#+RESULTS:
[[file:figures/tcp_client_side.png]]

* UDP like protocol
Simply send packets with serial number from the server at requested quality
(bitrate). Client side, just compute jitter, throughput and packet losses in a
certain time window based on what arrives: packet losses are easy to calculate
based on serial numbers.

#+BEGIN_SRC plantuml :file figures/udp_client_side.png :noweb yes
  <<plantuml_skin>>
  hide empty description

  state IDLE #f6ff9b

  state REQUEST {
    state REQUEST_INIT : # Pick unique session number for the stream\n# Start unusability timeout
    state REQUEST_WAIT : Send DATA request to server
  }
  state "RECEIVE   " as DATA {
    state DATA_INIT : # Clear all previous timeouts \n# Start new unusability timeout
    state DATA_WAIT
    state DATA_UPDATE : Update stream metrics
  }
  state UNUSABLE : Mark service as unusable
  state STOP_WAIT : Send STOP request to server
  state "IDLE" as FINISH #f6ff9b
  state EVALUATE : Compute QoS, QoE based on metrics

  IDLE --> REQUEST_INIT : User requests \nsome content
  IDLE --> STOP_WAIT : DATA packet received

  REQUEST --> UNUSABLE : N × t<sub>0</sub>

  REQUEST_INIT --> REQUEST_WAIT

  REQUEST_WAIT --> REQUEST_WAIT : t<sub>0</sub>
  REQUEST_WAIT --> DATA_INIT : DATA packet received

  DATA --> UNUSABLE : N × t<sub>0</sub>

  DATA_INIT --> DATA_WAIT

  DATA_WAIT -> DATA_UPDATE : DATA packet received
  DATA_WAIT -> EVALUATE : FINISH packet received

  DATA_UPDATE -> DATA_WAIT : \n

  UNUSABLE --> STOP_WAIT

  STOP_WAIT --> STOP_WAIT : t<sub>0</sub>
  STOP_WAIT --> EVALUATE : FINISH packet received

  EVALUATE --> FINISH
#+END_SRC

#+RESULTS:
[[file:figures/udp_client_side.png]]


#+BEGIN_SRC plantuml :file figures/udp_server_side.png :noweb yes
  <<plantuml_skin>>
  hide empty description

  state IDLE #f6ff9b
  state DATA {
  state DATA_SEND: Send DATA packet to the user
  state DATA_WAIT
  state "Has the stream ended?" as STREAM_ENDED
  }

  state FINISH_SEND : Send FINISH packet to the user
  state "IDLE" as FINISH  #f6ff9b

  IDLE --> DATA_SEND : DATA request received
  IDLE --> FINISH_SEND : STOP packet received

  DATA_SEND --> STREAM_ENDED

  STREAM_ENDED --> DATA_WAIT : NO
  DATA_WAIT --> DATA_SEND : Δt
  DATA_WAIT --> FINISH_SEND : STOP packet received
  STREAM_ENDED --> FINISH_SEND : YES

  DATA_SEND --> FINISH_SEND : STOP packet \nreceived

  FINISH_SEND --> FINISH
#+END_SRC

#+RESULTS:
[[file:figures/udp_server_side.png]]

* COMMENT Local variables
# Local Variables:
# org-confirm-babel-evaluate: nil
# eval: (add-hook 'org-babel-pre-tangle-hook (lambda () (org-babel-lob-ingest "thesis/thesis.org")) t t)
# eval:  (add-hook 'org-babel-after-execute-hook 'org-display-inline-images)
# End:
