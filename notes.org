#+STARTUP: latexpreview
#+STARTUP: indent
#+LATEX_HEADER: \usepackage{mathtools}

* ANALOGY Virtual Network Overlay as group of organizers of a fair
- people coming in are packets to be forwarded

- one all-knowing person cannot deal with all their specific needs, so
  - many people deal with simple tasks, redirecting visitors to common destinations
  - difficult (unusual) ones are sent to their supervisor, who knows more things
  - again, unusual requests are sent up to the supervisor of the supervisor, and so on

- the director has to be sure that all staff knows its needed information ~> controller

- a responsible is given the task to check if everybody is working properly (no congestion, no problems) and tell the director in case ~> monitor

* Traffic generation techniques, from "A Survey on the Common Network Traffic Sources Models"
** Bound (envelope) source traffic models
*** Deterministic Bound Interval Independent
Traffic function $A$ is limited by $A*$: $$ A[t,\, t + \tau] \le A^*(\tau) $$: deterministic and time-invariant bound.
cite:ChengShangChang1994

*** Stochastic Bound Traffic Models
Bound is *not* deterministic, but in probability: traffic function is likely to be smaller than the bound.

*** BIND Traffic Model

** Unbound (exact) Source Models

*** Poisson Distribution Model

*** Pareto Distribution Process

*** Markov Modulated Poisson Process

*** Markov Modulated Fluid Models

*** Autoregressive Models

*** Wavelet-based Models

*** Traffic Models Using Chaotic Maps
ex. Piecewise Linear Maps

*** N-Burst Traffic Model
Sum of N independent ON-OFF sources

* TODO thesis [0/3]
- [-] study WIDE dataset [1/3]
  - [X] preprocess dataset
  - [ ] study non-stationarity, and nice properties of the data cite:Anderson2017
  - [ ] obtain a realistic packet generator (ON/OFF, ...) that fits the data (see [[https://www.nsnam.org/docs/release/3.3/doxygen/application.html][here]] for ns3: seems reasonable)
- [ ] design wanted core network [0/2]
  - [ ] choose between OpenFlow and theoric routing optimization
  - [ ] write NS3 code
- [ ] learn how to optimize the network
  - [ ] write a reinforcement learning algo
  - [ ] run it

- [ ] design the network, based on Aachen population and topology
- [ ] check if traffic shaping can be performed by a controller, with packet recognition and with deep packet inspection
- [ ] measure performance

* things I have found
- o'Reilly book on MPLS/SDN: nice overwiev of the protocol cite:Szarkowicz2015
- overwiev on traditional packet generation techniques
- internet flows are not always stationary, gaussian and linear cite:Marnerides2018,Cao2001
- non-stationarity can be modeled using
  - Transformed Arma Models cite:Laner2014
  - time variant Poisson processed cite:Karagiannis2004
  - MFSG, GFSD cite:Anderson2017 (best paper, super recent)

* Aachen network estimation
- city has 200.000 people, spread across 160km2
- each person has (estimated) 40Mb/s in download and 8Mb/s in upload
- a single DSLAM can serve from 100 to 2000 people, with corresponding throughput required

* Optimization problem requirements
$G=(V, \,E)$ is the undirected city graph.
A direct graph $G^\prime = (V, A)$ is induced on top of if, where $ij \in E \Rightarrow ij, ji \in A$.

Each node is either a building or it is not.

\begin{equation}
  T = \left\{
    t \in V: t \text{ is a building}
  \right\}
\end{equation}

Each node can have at most one entering arc (tree constraint).

\begin{equation}
  \forall j \in V, \sum_{e \in \delta^-(j)} x_e \le 1
\end{equation}

** Objective function

\begin{equation}
  \min
  \sum_{t \in T} d_t \, c_f
  + \sum_{e \in E} x_e \, c_e
  + \sum_{j \in V} r_j \, c_D
\end{equation}

** Distance counter
Set the distance counter to a positive value (actual distance) below
maximum value $u_M$ if node is reached, otherwise fix it to $-u_M$.

\begin{equation}
  2 \, d_M \sum_{e \in \delta^-(j)} x_e \ge d_j + d_M
\end{equation}

\begin{equation}
  \implies
  \begin{dcases}
    d_j \le - d_M & \sum_{e \in \delta^-(j)} x_e = 0 \\
    d_j \le d_M & \sum_{e \in \delta^-(j)} x_e = 1
  \end{dcases}
\end{equation}

\begin{equation}
  d_j \ge \left( \sum_{e \in \delta^-(j)} x_e - 1 \right) d_M
\end{equation}

\begin{equation}
  \implies
  \begin{dcases}
    d_j \ge - d_M & \sum_{e \in \delta^-(j)} x_e = 0 \\
    d_j \ge 0 & \sum_{e \in \delta^-(j)} x_e = 1
  \end{dcases}
\end{equation}

If arc is active, make distance counter /effectively/ a counter.

\begin{equation}
  d_j - d_i \le l_{ij} + d_M (1 - x_{ij})
\end{equation}

\begin{equation}
  \implies
  \begin{dcases}
    d_j - d_i \le l_{ij} + d_M & x_{ij} = 0 \\
    d_j - d_i \le l{ij} & x_{ij} = 1
  \end{dcases}
\end{equation}

\begin{equation}
  d_j - d_i \ge l_{ij} - \left( d_M + l_{ij} \right) (1 - x_{ij})
\end{equation}

\begin{equation}
  \implies
  \begin{dcases}
    d_j - d_i \le - d_M & x_{ij} = 0 \\
    d_j - d_i \ge l_{ij} & x_{ij} = 1
  \end{dcases}
\end{equation}

Note that $d_i$ is *not* a distance for nodes not in a tree.
This is not a problem in our case, as its value is useful only for
terminal nodes, which are guaranteed to be reachable.

** Terminal reachability
Each building is connected to one of the trees.

\begin{equation}
  \forall t \in T,
  \sum_{e \in \delta^-(t)} x_e = 1
\end{equation}

which is stronger than

\begin{equation}
  \forall t \in T, \, d_t \ge 0
\end{equation}

** Counting root nodes
Let $\delta_M$ be the maximum degree of the nodes in $G$.

\begin{equation}
  r^\prime_j =
  \frac{1}{\delta_M}
  \left( \sum_{e \in \delta^+(j)} x_e \right) -
  \sum_{e \in \delta^-(j)} x_e
\end{equation}

\begin{equation}
  r^\prime_j ~ \begin{dcases}
    \in (0, 1] & j \text{ is root of its tree} \\
    = 0 & j \text{ is not part of any tree} \\
    < 0 & j \text{ is not the root of its tree} \\
  \end{dcases} \\
\end{equation}

Given this metric, $r_j$ is an indicator of the node $j$ being root or not.
$r^\prime_j = 0 \wedge r_j = 1$ is "discouraged" by objective function.

TODO check if another constraint is needed here, to be sure

\begin{equation}
  r_j \ge r^\prime_j
\end{equation}

\begin{equation}
  r_j =
  \begin{dcases}
    1 & j \text{ is root of its tree} \\
    0 & j \text{ otherwise} \\
  \end{dcases}
\end{equation}

** Counting terminals per tree
Let $n_j$ be the number of terminal nodes in the subtree below node $j$.

In a subtree there can be up to $|T|$ terminals, so $n^\prime_{ij}$ is defined as

\begin{equation}
  \begin{dcases}
    n_j - |T| \, ( 1 - x_{ij}) \le n^\prime_{ij} \le |T| \, x_{ij} \\
    n^\prime_{ij} \le n_j \\
    n^\prime_{ij} \ge 0
  \end{dcases}
\end{equation}

Which means that
\begin{equation}
  n^\prime_{ij} =
  \begin{dcases}
    n_j & x_{ij} = 1 \\
    0 & x_{ij} = 0 \\
  \end{dcases}
\end{equation}

Then our variable can be computed linearly as

\begin{equation}
  n_i
  = \begin{dcases}
      1 & i \in T \\
      \sum_{e \in \delta^+(i)} n^\prime_{e} & i \notin T \\
  \end{dcases}
\end{equation}

Given $n_M$, maximum number of terminal per tree, programming is constrained by

\begin{equation}
  n_i \le n_M
\end{equation}


* COMMENT Local variables
# Local Variables:
# eval: (add-hook 'after-save-hook 'org-render-latex-fragments t t)
# End:
