#+STARTUP: latexpreview
#+STARTUP: indent

#+PROPERTY: header-args :cache yes

#+OPTIONS: toc:nil title:nil

#+LaTeX_CLASS: article
#+LATEX_HEADER: \usepackage{charter}
#+LATEX_HEADER: \usepackage[charter]{mathdesign}

#+LATEX_HEADER: \usepackage{geometry}
#+LATEX_HEADER: \usepackage{etoolbox}
#+LATEX_HEADER: \usepackage{multirow}
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \graphicspath{{../figures/}}
#+LATEX_HEADER: \usepackage{subcaption}

#+LATEX_HEADER: \usepackage{mathtools}
#+LaTeX_HEADER: \usepackage{booktabs}
#+LaTeX_HEADER: \usepackage{amsmath}

#+LaTeX_HEADER: \usepackage{algpseudocode}
#+LaTeX_HEADER: \usepackage{algorithm}

#+LaTeX_HEADER: \allowdisplaybreaks
#+LaTeX_HEADER: \def\equationautorefname#1#2\null{(#2\null)}
#+LaTeX_HEADER: \def\algorithmautorefname#1#2\null{Algorithm #2\null}
#+LATEX_HEADER: \providetoggle{images_titlepage}
#+LATEX_HEADER: \settoggle{images_titlepage}{true}

#+LaTeX_HEADER: \setlength{\parindent}{0cm}
#+LATEX_HEADER: \setlength{\parskip}{0.25em}

#+LATEX_HEADER: \usepackage{glossaries}
#+LATEX_HEADER_EXTRA: \newacronym{pop}{PoP}{Point of Presence}
#+LATEX_HEADER_EXTRA: \newacronym{dslam}{DSLAM}{Digital Subscriber Line Access Multiplexer}
#+latex_header_extra: \newacronym{qos}{QoS}{Quality of Service}
#+latex_header_extra: \newacronym{ilp}{ILP}{Integer Linear Programming}
#+latex_header_extra: \newacronym{tbf}{TBF}{Token Bucket Filter}

#+LATEX_HEADER: \makeatletter
#+LATEX_HEADER: \newenvironment{bigalgorithm}
#+LATEX_HEADER:   {% \begin{bigalgorithm}
#+LATEX_HEADER:    \begin{center}
#+LATEX_HEADER:      \refstepcounter{algorithm}% New algorithm
#+LATEX_HEADER:      \hrule height.8pt depth0pt \kern2pt% \@fs@pre for \@fs@ruled
#+LATEX_HEADER:      \renewcommand{\caption}[2][\relax]{% Make a new \caption
#+LATEX_HEADER:        {\raggedright\textbf{\ALG@name~\thealgorithm} ##2\par}%
#+LATEX_HEADER:        \ifx\relax##1\relax % #1 is \relax
#+LATEX_HEADER:          \addcontentsline{loa}{algorithm}{\protect\numberline{\thealgorithm}##2}%
#+LATEX_HEADER:        \else % #1 is not \relax
#+LATEX_HEADER:          \addcontentsline{loa}{algorithm}{\protect\numberline{\thealgorithm}##1}%
#+LATEX_HEADER:        \fi
#+LATEX_HEADER:        \kern2pt\hrule\kern2pt
#+LATEX_HEADER:      }
#+LATEX_HEADER:   }{% \end{bigalgorithm}
#+LATEX_HEADER:      \kern4pt\hrule\relax% \@fs@post for \@fs@ruled
#+LATEX_HEADER:    \end{center}
#+LATEX_HEADER:   }
#+LATEX_HEADER: \makeatother

* Utility code :ignore:
** PlantUML common style :ignore:
#+BEGIN_COMMENT
PlantUML skin, reusable for all diagrams
#+END_COMMENT

#+NAME: plantuml_skin
#+BEGIN_SRC plantuml :exports none
  skinparam shadowing false
  skinparam padding 1
  skinparam BoxPadding 1

  'skinparam DefaultFontName Charter
  skinparam DefaultFontName Fira Sans

  skinparam defaultTextAlignment center

  skinparam SequenceDelayFontSize 15

  skinparam Note {
  BackgroundColor white
  BorderColor     black
  FontColor       black
  }

  skinparam Node {
  BackgroundColor white
  BorderColor     black
  FontColor       black
  }

  skinparam Cloud {
  BackgroundColor white
  BorderColor     black
  FontColor       black
  }

  skinparam Database {
  BackgroundColor white
  BorderColor     black
  FontColor       black
  }

  skinparam Actor {
  BackgroundColor white
  BorderColor     black
  FontColor       black
  }

  skinparam Activity {
  BackgroundColor white
  BorderColor     black
  FontColor       black
  }

  skinparam activityDiamond {
  BackgroundColor white
  BorderColor black
  FontColor       black
  }

  skinparam ArrowColor black

  skinparam State {
  BackgroundColor white
  BorderColor     black
  FontColor       black
  }

  skinparam SequenceParticipant {
  BackgroundColor white
  BorderColor     black
  FontColor       black
  }

  skinparam Interface {
  BackgroundColor white
  BorderColor     black
  FontColor       black
  }

  skinparam SequenceLifeLine {
  BorderColor black
  BackgroundColor black
  }

  skinparam Queue {
  BackgroundColor white
  BorderColor     black
  FontColor       black
  }

  skinparam Usecase {
  BackgroundColor white
  BorderColor     black
  FontColor       black
  }
#+END_SRC

** Download university logos :ignore:
#+BEGIN_COMMENT
Download all needed files for titlepage and convert them.
LaTeX support for svg files sucks.
#+END_COMMENT

#+BEGIN_SRC bash :exports none :results none
  wget https://upload.wikimedia.org/wikipedia/it/5/53/Logo_Universit%C3%A0_Padova.svg \
       -O ../figures/logo_unipd.svg

  inkscape ../figures/logo_unipd.svg --export-pdf=../figures/logo_unipd.pdf

  wget https://upload.wikimedia.org/wikipedia/commons/1/11/RWTH_Logo.svg \
       -O ../figures/logo_rwth.svg

  inkscape ../figures/logo_rwth.svg --export-pdf=../figures/logo_rwth.pdf
#+END_SRC

** Latex title page :ignore:
#+BEGIN_EXPORT latex
\newgeometry{top=1in, bottom=1in, inner=1in, outer=1in}
\begin{titlepage}
  {\Large University of Padova}
  \vspace{5mm}

  {\Large Department of Information Engineering}

  \begin{center}
    \vspace{1cm}
    {\Large \textsl{Master degree in Telecommunication Engineering}} \\
    \vspace{1cm}
    {\scshape\huge Traffic flow optimization \\[0.3em] for urban xDSL based access networks }

    \iftoggle{images_titlepage}{
      \vspace{1cm}
      \begin{figure}[h]
        \centering
        \includegraphics[height=5cm]{logo_unipd.pdf}
        \vspace{0.5cm} \\
        \includegraphics[height=2cm]{logo_rwth.pdf}
      \end{figure}
    }

  \end{center}

  \vfill
  \hspace{0.5cm}%
  \renewcommand{\arraystretch}{2.5}
  \begin{tabular}{lr}
    \large \textsl{Author}               & \hspace{5mm} \large Enrico Lovisotto      \\
    \large \textsl{Internal supervisor}  & \hspace{5mm} \large Prof. Andrea Zanella  \\
    \large \textsl{External supervisors} & \hspace{5mm} \large Prof. Petri Mähönen  \\
                                         & \hspace{5mm} \large Dr. Ljiljana Simić   \\
  \end{tabular}
  \vspace{1cm}

  \hfill{\large February 6, 2019} \vspace{2mm}

  \hfill{\Large Academic year 2018-2019 \par}
\end{titlepage}

\restoregeometry
#+END_EXPORT

** Asymptote preamble :ignore:
#+NAME: asymptote_preamble
#+BEGIN_SRC asymptote :exports none
  settings.outformat="pdf";

  texpreamble("\usepackage[sfdefault]{Fira Sans}");
  texpreamble("\usepackage{newtxsf}");

  // texpreamble("\usepackage{charter}");
  // texpreamble("\usepackage[charter]{mathdesign}");
#+END_SRC

* Introduction
#+BEGIN_SRC org :exports none
  + background: what are we talking about?
    - SDN => self-optimizing networks
    - flow balancing (TBF)
    - routing adaptation

  + what they do now?
    - summary of state of the art, /basically/

  + shortcomings in current knowledge / solutions
    - limits of SDN over traditional networks: lack of negative results
    - use of abstract topologies ~> this one is obtained through optimization process

  + what are we gonna prove?
    - 99% if the networks are very simple, meant to be more flow aggregators and less clever routers
    - SDN are not inherently good: /probably/ traditional solutions are good in 99% of the networks
    - SDN are relevant when the complexity of the network grows
#+END_SRC
* State of the art

#+BEGIN_SRC org :exports none
  One subsection for each of the macro-areas

  - maps -> network topology
    - Steiner tree
    - ...

  - flow control
    - fairness in network management ~> Nash arbitration point

  - heuristic control of the network
#+END_SRC

* Methodology
:PROPERTIES:
:CUSTOM_ID: methodology
:END:

This section will discuss which theoretical framework and tools that have been used
throughout the analysis and the motivation behind them.

First, in autoref:methodology-geographical_analysis, we will analyze the Aachen
buildings and roads in order to design, in autoref:methodology-network_design, a
proper access network based on city topology and population density.

Once obtained a suitable structure, its parameters are optimized in
autoref:methodology-flow_optimization using a genetic algorithm, building an
effectively self-learning framework.

** Geographical analysis
:PROPERTIES:
:CUSTOM_ID: methodology-geographical_analysis
:END:

#+BEGIN_SRC org :exports none
  OpenStreetMap ~> roads + buildings graph: only methodological consideration

  + cutting NRW maps with Aachen border
  + selecting roads & buildings type
  + ~s2g~ to obtain the graph ~> cite stuff using this approach
    - road polygons to edges
    - intersections as nodes
  + adding building to the graph
    - splitting roads
    - population estimated based on district population, building area
#+END_SRC

The city of Aachen is located in the north-west of Germany, in state of North
Rhine-Westphalia. Its district has a surface of 160.85km² and a population of
244951 citizens.

Although medium sized, the city is an important telecommunication node between
Germany and the neighbour countries of Belgium and Netherlands. The LambdaNet
backbone, owned by /euNetworks Managed Services GmbH/, crosses in fact the city
and provides direct connection to public Internet. Its map, built by ``The
Internet Topology Zoo'' project cite:topology_zoo, has been plotted in
autoref:fig:lambdanet.

#+LABEL: fig:lambdanet
#+CAPTION: LambdaNet is a national backbone that serves all German major cities and connects the country to the rest of Europe.
[[file:~/Archivi/tesi/figures/german_backbone.pdf]]

In this thesis we will then suppose that the access network connects all Aachen
buildings to this main backbone via a single [[ac:pop][PoP]], located in the industrial
district of the city.

Unfortunately, schematics for such network are not publicly available, so we
have to perform what it is called an /educated guess/, meaning a good estimation
based on available information.

The evaluation will be performed using OpenStreetMap cite:OpenStreetMap in
conjunction with the /Open Data Portal/ of the city of Aachen [fn:1]: the former
provides buildings and roads positions, while the latter describes how
population is distributed across the city districts.

[fn:1] Please refer to http://daten.aachen.de for further information and licensing.


All this information can be visualized in the map of
[[autoref:fig:aachen_city_map]], in the autoref:results-geographical_analysis.

\bigbreak

Due to the level of detail of these datasets, two assumptions are needed to
proceed and extract a reasonable diagram for the access city network.

First, we suppose cables to be put along streets and not to cross (even public)
terrains. This is common practice in contexts like ours, since all the roadwork
the city is frequently under is exploited to perform maintenance and build new
parts of the network.

Second, we consider the population of a given area to be uniformly distributed
across a fraction of its buildings, so-called /residential/ ones, randomly
picked across all the constructions. \\
We have to take this strong hypothesis because the OpenStreetMap dataset lacks
information about the building use and its height in most entries.

I consider these two points acceptable, since we want to analyze how the access
network of a city like Aachen behaves, not to replicate it in perfect detail.

This information is then condensed in an abstract graph, with streets as edges
and road crossing as vertices. The former were given corresponding lane length,
while the latter were assigned the supposed number of people living in the
surrounding area.

** Network design
:PROPERTIES:
:CUSTOM_ID: methodology-network_design
:END:

#+BEGIN_SRC org :exports none
  Using ILP to build the network

  - network requirements
    + ISP recommendations
    + best practices (CISCO, ...)
  - actual solution we are trying to find
    + optimal DSLAM positioning
    + optimal + heuristic check for routers and mainframe positions (restrict root nodes?)
  - why ILP? how does it work? (brief)
  - problem definition
    + idea for the model: Steiner tree + other constraints (cite requirements)
    + actual equations
  - problem complexity: number of variables, constraints (in theory)
#+END_SRC

Previous pre-processing on Aachen city map allowed us to summarize in an
undirected graph $G=(V, \,E)$ all relevant information about the streets
topology, buildings and estimated number of users.

As specified earlier, each node $i$ is assigned a number of users $u_i$ to serve
and, since that they represent a physical line, edges are given a length value
$l_e$: both these parameters will be used later to evaluate the access network
cost.

In this chapter we will exploit this information to find the optimal network
configuration, given some assumptions and requirements derived from best
practices in access network design. cite:CiscoWAN

*** Topology considerations
As depicted in autoref:fig:network_tree we suppose our access network to be made of
layer-2 type switches and to be logically shaped as a tree.

This seemingly strong assumption is confirmed to be common practice in such
access networks, where more complex and elaborate topologies are too expensive
and offer no substantial benefit. cite:CiscoWAN

In this configuration the path from users to the provider mainframe is fixed and
must cross two kinds of intermediate nodes, a [[acp:dslam][DSLAM]] and a router, whose main
task is to aggregate all the traffic further and further.

#+BEGIN_SRC plantuml :file ../figures/network_tree.eps :noweb yes
  <<plantuml_skin>>
  skinparam nodesep 10

  queue Backbone as b

  rectangle Mainframe as m #ff9b9b

  rectangle Router as r1 #ffda9b
  rectangle Router as r2 #ffda9b
  rectangle Router as r3 #ffda9b

  rectangle DSLAM as d1 #f6ff9b
  rectangle DSLAM as d2 #f6ff9b
  rectangle DSLAM as d3 #f6ff9b
  rectangle DSLAM as d4 #f6ff9b
  rectangle DSLAM as d5 #f6ff9b
  rectangle DSLAM as d6 #f6ff9b

  interface " " as c1
  interface " " as c2
  interface " " as c3
  interface " " as c4
  interface " " as c5
  interface " " as c6
  interface " " as c7
  interface " " as c8
  interface " " as c9
  interface " " as c10
  interface " " as c11
  interface " " as c12
  interface " " as c13
  interface " " as c14
  interface " " as c15
  interface " " as c16
  interface " " as c17
  interface " " as c18

  b -- m

  m -- r1
  m -- r2
  m -- r3

  r1 -- d1
  r1 -- d2
  r2 -- d3
  r2 -- d4
  r3 -- d5
  r3 -- d6

  d1 -- c1
  d1 -- c2
  d1 -- c3
  d2 -- c4
  d2 -- c5
  d2 -- c6
  d3 -- c7
  d3 -- c8
  d3 -- c9
  d4 -- c10
  d4 -- c11
  d4 -- c12
  d5 -- c13
  d5 -- c14
  d5 -- c15
  d6 -- c16
  d6 -- c17
  d6 -- c18

  r1 -[hidden] r2
  r2 -[hidden] r3

  d1 -[hidden] d2
  d2 -[hidden] d3
  d3 -[hidden] d4
  d4 -[hidden] d5
  d5 -[hidden] d6

  c1 -[hidden] c2
  c2 -[hidden] c3
  c3 -[hidden] c4
  c4 -[hidden] c5
  c5 -[hidden] c6
  c6 -[hidden] c7
  c7 -[hidden] c8
  c8 -[hidden] c9
  c9 -[hidden] c10
  c10 -[hidden] c11
  c11 -[hidden] c12
  c12 -[hidden] c13
  c13 -[hidden] c14
  c14 -[hidden] c15
  c15 -[hidden] c16
  c16 -[hidden] c17
  c17 -[hidden] c18
#+END_SRC

#+LABEL: fig:network_tree
#+CAPTION: A layered tree access network connects users (circles) to the Internet backbone
#+ATTR_LATEX: :height 3.5in
#+RESULTS[8ea501892da9a680d09dae6c57f8da0bec56e358]:
[[file:../figures/network_tree.eps]]

From a technological point of view the network is considered to be relatively
modern, since the infrastructure has been renewed on the past years in
conjuction with works on main city roads.

That is the reason why we suppose all main links to be fiber optic ones running
state-of-the-art VDSL/VDSL2. The minor fraction of legacy ADSL and copper-cable
users can be well approximated as VDSL connections at the same distance, in
terms of bandwidth and other network metrics.

# TODO citation needed

In order to guarantee a suitable [[ac:qos][QoS]], all connected network components have to
be close enough to each other: this is taken into account though a maximum
distance parameter $d_M$.

Finally, to make the tree a plausible topology each switch is allowed to serve a
limited number $n_M$ of lower level nodes, given by the number of physical ports
of the device.

*** Solution approach
:PROPERTIES:
:CUSTOM_ID: solution-approach
:END:

In smaller context, an handmade network is often enough to meet all wanted
conditions while being reasonably cheap. This is not our case, since the set of
possible topologies is far too vast for a manual evaluation: a programmatic
strategy is then necessary to proceed.

Problems on graphs similar to the one we face are often solved using either [[ac:ilp][ILP]]
or an heuristic approach. cite:Koch1998,Rehfeldt2015,Diane1993,Leitner2014 \\
The former is a powerful mathematical tool that finds the best possible solution
to the problem, but it is very demanding with respect to computational resources
and time. \\
The latter instead does not strive to give the optimum, but can hopefully
achieve decent results in a more reasonable amount of time.

My first attempt involved writing the mathematical model to describe the
multi-layered system as a whole, but it was immediately clear that it would have
been to complex, as the solver can handle a limited amount of variables and
constraints.

To overcome this issue I moved to a different way of designing the topology.
Instead of positioning all the nodes at once, the solver would place the leaves
of the tree, meaning the [[ac:dslam][DSLAM]]s, first and then move up to the higher-level
elements. \\
This is closer to what is done in practice, as each step is examined and
evaluated according to criteria, such as soundness and future-proofing of the
infrastructure, that are difficult to explain to the solver.

The network topology moves then from the one in [[autoref:fig:network_tree]] to the
simplified setting of autoref:fig:network_tree_simplified.

#+BEGIN_SRC plantuml :file ../figures/network_tree_simplified.eps :noweb yes
  <<plantuml_skin>>
  skinparam nodesep 10

  queue Backbone as b

  rectangle Mainframe as r #ff9b9b

  rectangle Head as d1 #f6ff9b
  rectangle Head as d2 #f6ff9b
  rectangle Head as d3 #f6ff9b
  rectangle Head as d4 #f6ff9b
  rectangle Head as d5 #f6ff9b
  rectangle Head as d6 #f6ff9b

  interface " " as c1
  interface " " as c2
  interface " " as c3
  interface " " as c4
  interface " " as c5
  interface " " as c6
  interface " " as c7
  interface " " as c8
  interface " " as c9
  interface " " as c10
  interface " " as c11
  interface " " as c12
  interface " " as c13
  interface " " as c14
  interface " " as c15
  interface " " as c16
  interface " " as c17
  interface " " as c18

  b -- r

  r -[dashed]- d1
  r -[dashed]- d2
  r -[dashed]- d3
  r -[dashed]- d4
  r -[dashed]- d5
  r -[dashed]- d6

  d1 -- c1
  d1 -- c2
  d1 -- c3
  d2 -- c4
  d2 -- c5
  d2 -- c6
  d3 -- c7
  d3 -- c8
  d3 -- c9
  d4 -- c10
  d4 -- c11
  d4 -- c12
  d5 -- c13
  d5 -- c14
  d5 -- c15
  d6 -- c16
  d6 -- c17
  d6 -- c18

  d1 -[hidden] d2
  d2 -[hidden] d3
  d3 -[hidden] d4
  d4 -[hidden] d5
  d5 -[hidden] d6

  c1 -[hidden] c2
  c2 -[hidden] c3
  c3 -[hidden] c4
  c4 -[hidden] c5
  c5 -[hidden] c6
  c6 -[hidden] c7
  c7 -[hidden] c8
  c8 -[hidden] c9
  c9 -[hidden] c10
  c10 -[hidden] c11
  c11 -[hidden] c12
  c12 -[hidden] c13
  c13 -[hidden] c14
  c14 -[hidden] c15
  c15 -[hidden] c16
  c16 -[hidden] c17
  c17 -[hidden] c18
#+END_SRC

#+LABEL: fig:network_tree_simplified
#+CAPTION: Each /head/ aggregates the traffic of all nodes in its /cluster/.
#+ATTR_LATEX: :height 2.5in
#+RESULTS[5085dfc30f26ccf8321faf35dc8ee483110cc158]:
[[file:../figures/network_tree_simplified.eps]]

As apparent in the diagram the solver must now take into consideration the cost
of the nodes that have been omitted from the tree. This is accounted as a lump
sum for the connection of each network switch, called from now on cluster
/head/, to the mainframe both in terms of cables and intermediate nodes.

Both the exact and approximated approach that will be propose the access network
structure will consider a topology built in this fashion, starting from the
periphery and moving towards the core of the network.

All relevant parameters have been collected in [[autoref:quantities_constraints]] and
will be taken for granted from now on.

#+NAME: quantities_constraints
#+CAPTION: Problem parameters, divided in topology specific ones, technological limits and costs.
#+ATTR_LATEX: :align cl
| Variable        | Description                                                   |
|-----------------+---------------------------------------------------------------|
| $G = (V, \, E)$ | Graph describing the city topology                            |
| $T \subseteq V$ | Set of terminal nodes                                         |
| $l_e = l_{ij}$  | Length of edge $e = (i,\,j) \in E$                            |
| $u_i$           | Number of users at terminal $i \in T$                         |
|-----------------+---------------------------------------------------------------|
| $d_M$           | Maximum distance from a terminal and its root                 |
| $n_M$           | Maximum number of terminals per tree                          |
|-----------------+---------------------------------------------------------------|
| $c_r$           | Cost of a single subtree root node, plus mainframe connection |
| $c_f$           | Cost of a fiber optic cable per meter                         |
| $c_e$           | Cost of roadwork excavation per meter                         |

*** ILP formulation
In order to express the optimization problem in a convenient way, we arrange our
data as follows.

A direct graph $G^\prime = (V \cup \{r\},\, A)$ is induced on top of the $G$, where
the set of arcs $A$ is defined as follows.

#+NAME: induction_G
\begin{equation}
  A = \left\{ (i,\,j),\, (j,\,i) ~~ \forall \{i, j\} \in E \right\} \cup
  \left\{ (r,\,j) ~ \forall j \in V \right\}
\end{equation}

In autoref:induction_G each undirected edge in $E$ is doubled with the two
corresponding directed arcs; then an artificial node $r$ is added to the
vertices set and connected to each of the nodes in $V$.

Each arc $(i,\,j) \in A$ is assigned a length, in meters $l_{ij}$, given by the
geographical distance between its endpoints. Artificial arcs $(r,\,j)$ do not
correspond to physical connections and so $l_{rj} = 0 ~~ \forall j \in V$.

With this setup our network access configuration will simply be a direct tree, or
/arborescence/, with root in $r$, as depicted in autoref:fig:tree_network.

#+BEGIN_SRC plantuml :file ../figures/ilp_graph_reduced.eps :noweb yes
  <<plantuml_skin>>
  skinparam nodesep 10

  skinparam ArrowFontSize 25
  skinparam UsecaseFontSize 25
  hide empty description

  usecase "r" as r #ff9b9b

  usecase " " as d1 #f6ff9b
  usecase " " as d2 #f6ff9b
  usecase " " as d3 #f6ff9b
  usecase " " as d4 #f6ff9b
  usecase " " as d5 #f6ff9b
  usecase "i" as d6 #f6ff9b

  usecase " " as c1
  usecase " " as c2
  usecase " " as c3
  usecase " " as c4
  usecase " " as c5
  usecase " " as c6
  usecase " " as c7
  usecase " " as c8
  usecase " " as c9
  usecase " " as c10
  usecase " " as c11
  usecase " " as c12
  usecase " " as c13
  usecase " " as c14
  usecase " " as c15
  usecase " " as c16
  usecase " " as c17
  usecase " " as c18

  usecase " " as n1
  usecase " " as n2
  usecase " " as n3
  usecase " " as n4
  usecase " " as n5
  usecase " " as n6
  usecase " " as n7
  usecase " " as n8
  usecase " " as n9
  usecase " " as n10
  usecase " " as n11
  usecase " " as n12
  usecase " " as n13
  usecase " " as n14
  usecase " " as n15
  usecase " " as n16
  usecase " " as n17
  usecase " " as n18
  usecase " " as n19
  usecase " " as n20
  usecase " " as n21
  usecase " " as n22
  usecase " " as n23
  usecase " " as n24

  r -[#ff5050]->> d1
  r -[#ff5050]->> d2
  r -[#ff5050]->> d3
  r -[#ff5050]->> d4
  r -[#ff5050]->> d5
  r -[#ff5050]->> d6 : "(r, i)"

  d1 -->> c1
  d1 -->> c2
  d1 -->> c3
  d2 -->> c4
  d2 -->> c5
  d2 -->> c6
  d3 -->> c7
  d3 -->> c8
  d3 -->> c9
  d4 -->> c10
  d4 -->> c11
  d4 -->> c12
  d5 -->> c13
  d5 -->> c14
  d5 -->> c15
  d6 -->> c16
  d6 -->> c17
  d6 -->> c18

  c1  -->> n1
  c1  -->> n2
  c2  -->> n3
  c3  -->> n4
  c4  -->> n5
  c5  -->> n6
  c5  -->> n7
  c6  -->> n8
  c7  -->> n9
  c8 -->> n10
  c8 -->> n11
  c8 -->> n12
  c9 -->> n13
  c9 -->> n14
  c10 -->> n15
  c11 -->> n16
  c11 -->> n17
  c12 -->> n18
  c14 -->> n19
  c15 -->> n20
  c15 -->> n21
  c16 -->> n22
  c18 -->> n23
  c18 -->> n24

  d1 -[hidden] d2
  d2 -[hidden] d3
  d3 -[hidden] d4
  d4 -[hidden] d5
  d5 -[hidden] d6

  c1 -[hidden] c2
  c2 -[hidden] c3
  c3 -[hidden] c4
  c4 -[hidden] c5
  c5 -[hidden] c6
  c6 -[hidden] c7
  c7 -[hidden] c8
  c8 -[hidden] c9
  c9 -[hidden] c10
  c10 -[hidden] c11
  c11 -[hidden] c12
  c12 -[hidden] c13
  c13 -[hidden] c14
  c14 -[hidden] c15
  c15 -[hidden] c16
  c16 -[hidden] c17
  c17 -[hidden] c18
#+END_SRC

#+LABEL: fig:tree_network
#+CAPTION: In the final solution, additional arcs $(r,\, i)$ connect artifical node $r$ to all the roots, making the whole structure an arborescence, instead of a forest.
#+ATTR_LATEX: :width \linewidth
#+RESULTS[73e203a14ca9323ed263eab6c671feafb662aded]:
[[file:../figures/ilp_graph_reduced.eps]]

Because of the system requirements we also have to keep track of the distance
$d_i$ of each node $i \in V \cup \{r\}$ from its head and the number of users $n_e$ served
by each link in $A$, ensuring they don't exceed their limits.

Given this setup, our optimization problem can be written as

\begin{align}
  \text{minimize ~~}
  & \left( \sum_{t \in T} d_t \, u_t \right) \, c_c
    + \left( \sum_{e \in E} x_e \, l_e \right) \, c_e
    + \left( \sum_{e \in \delta^+(r)} x_e \right) \, c_r
    \label{eq:obj_function} \\[0.8em]
  \text{subject to ~~}
  & \sum_{e \in \delta^-(j)} x_e ~
    \begin{dcases}
      = 0 & j = r \\
      = 1 & j \in T \\
      \le 1 & j \in V \setminus T
    \end{dcases} \label{eq:single_arc_in} \\[0.5em]%
    % & \forall j \in V, \sum_{e \in \delta^+(j)} x_e
    % \le \left( \sum_{e \in \delta^-(j)} x_e \right)
    % \, \max_{v \in V} \left| \delta^+(v) \right|
    % \label{eq:nodes_reachability} \\[0.5em]
  & \sum_{e \in \delta^+(r)} x_e \ge 1
    \label{eq:r_active} \\[0.5em]
  & \forall j \in V \cup \{r\}, ~ d_j \le \left( \sum_{e \in \delta^-(j)} x_e \right) d_M
    \label{eq:distance_upper_limit} \\[0.2em]
  & \forall (i,\,j) \in A ~
    \begin{dcases}
      ~ d_j - d_i \ge l_{ij} ~ x_{ij} - d_M \, (1 - x_{ij}) \\[0.2em]
      ~ d_j - d_i \le l_{ij} ~ x_{ij} + d_M \, (1 - x_{ij})
    \end{dcases}
  \label{eq:distance_progression} \\[1.5em]
  & \forall e \in A,\, n_e \le x_e \, n_M
    \label{eq:n_terminals_upper_limit} \\
  & \sum_{e \in \delta^-(j)} n_e - \sum_{e \in \delta^+(j)} n_e =
    \begin{dcases}
      ~ p_j & j \in T \\[0.2em]
      ~ 0 & j \in V \setminus T
    \end{dcases} \label{eq:n_flow_balance} \\[0.5em]
  & \sum_{e \in \delta^+(r)} n_e = \sum_{i \in T} u_i
    \label{eq:root_sink} \\[0.8em]
  & \forall e \in A, \, x_e \in \{0, \, 1\}, \, n_e \in \mathbb{N} \cup \{0\}
    \label{eq:var_domain_1} \\[0.5em]
  & \forall j \in V \cup \{r\}, \, d_j \ge 0
    \label{eq:var_domain_2}
\end{align}

To clear the notation, we have defined functions $\delta^+, \, \delta^-: V \rightarrow
\mathbb{P}(A)$ associating each node with the out-going and in-going edges
respectively.

\begin{equation}
  \begin{split}
    \delta^+(j) &= \left\{ (j,\,k) \in A \right\} \\
    \delta^-(j) &= \left\{ (i,\,j) \in A \right\} \\
  \end{split}
\end{equation}

The problem is set to minimize the objective function autoref:eq:obj_function
that sums up the cost of optical fiber lines, roadworks and the total price of
/head/ switching units.

The first constraint autoref:eq:single_arc_in forces the terminals to be connected
to our network and sets the number of in-going arcs to be at most one, which is a
necessary condition for the network to be a directed tree.

As the leaves are set to be part of the network, $r$ has to be as well by
autoref:eq:r_active. It will then be the root node of the resulting tree, as by
construction of $G^\prime$ node $r$ has no in-going arcs.

The next equations deal with the variables $d_j$, distance from the tree root.
First, in autoref:eq:distance_upper_limit this quantity is limited by $d_M$ if
the node is reached by the network, otherwise it is set to zero. \\
On the other hand autoref:eq:distance_progression guarantees the consistency of
this metric between two connected nodes, forcing target node distance to be the
source one plus the link length. \\
Implicitly the latter prevents the resulting network to have loops, necessary
for our solution to be a proper arborescence.

The last needed metric for limiting the possible solutions is the number of
users each link can handle, $n_M$. This upper limit for $n_e$ is set in
autoref:eq:n_terminals_upper_limit such that it has to hold only for active
edges, and then the count of the users from leaves to each sub-root is performed
in autoref:eq:n_flow_balance, which has the same form as a flow-conservation
clause. \\
All such flows must converge towards the root $r$ for autoref:eq:root_sink: this
forces the network to be connected, finally giving it the wanted shape.

Variable domains are eventually specified in autoref:eq:var_domain_1 and
autoref:eq:var_domain_2.

\bigbreak

Overall, the model requires $|V| + 1 + 4 \, |E|$ variables and $3\, |V| +
2\,|T| + 4 \, |E| + 1$ constraints, both of which are $O(|V|)$ for sparse graphs like the one we are working on.

*** Heuristic algorithm
:PROPERTIES:
:CUSTOM_ID: methodology-heuristic
:END:

The mathematical problem described in the previous section can be effectively
solved only for small instances, i.e. sparse graphs with up to one hundred
nodes. \\
In fact, when tested on our specific case with tens of thousands of nodes and
edges, the program could not output the solution within a reasonable amount of
time and resources.

An heuristic approach had to be devised: I chose for the peculiarities of the
problem a greedy approach, inspired by the hierarchical clustering.

The basic idea is to progressively join single nodes of the graph in bigger and
bigger /clusters/ until it is cheaper to do so. \\
Such merges are allowed whenever the previously mentioned [[ac:qos][QoS]] constraints are
met and adjacent subsets are preferred. To be precise, distance between each
couple of groups is defined as the distance of the closest elements: this is
done to privilege more cohesive and compact pairs.

This procedure is repeated until all possible choices have been considered or
the next merge increases the cost of the network.

Pseudo-code is available in [[autoref:lst:alg:heuristic]].

\begin{bigalgorithm}
  \label{lst:alg:heuristic}
  \begin{algorithmic}
    \caption{Heuristic solver}
    % \State /* \quad \textsc{init} phase \quad */
    \State $C=\emptyset$
    \State $\forall\, t \in T$ add singleton $\{t\}$ to $C$
    \State mark all couples $C_i, C_j \in C^2$ as mergeable
    \State cost = \Call{objective\_function}{$C$}
    \State
    \State stop = False
    \Repeat
    % \State /* \quad \textsc{iteration} phase \quad */
    \State pick $C_i$ and $C_j$ the two closest clusters in $C$
    \State $d_{ij}$ = diameter of cluster $C_i \cup C_j$
    \State $n_{ij}$ = number of users inside $C_i \cup C_j$
    \State
    \If {$d_{ij} < 2 \, d_M$ and $n_{ij} < n_M$}
    \State $C^\prime = \{C_1, \ldots, C_i \cup C_j, \ldots \}$
    \State current\_cost = \Call{objective\_function}{$C^\prime$}
    \State
    % \State /* \quad \textsc{performance} stop condition \quad */
    \If {current\_cost > cost}
    \State stop = True
    \Else
    \State $C = C^\prime$
    \EndIf
    \State merge $C_i$ and $C_j$
    \Else
    \State mark the couple $C_i$ and $C_j$ as unmergeable
    \EndIf
    \State
    % \State /* \quad \textsc{exhaustion} stop condition \quad */
    \If {$\nexists \, C_i, C_j \in C^2$ mergeable}
    \State stop = True
    \EndIf
    \Until { stop = False }
    \State
    \State\Return $C$
  \end{algorithmic}
\end{bigalgorithm}

The cost of each sub-network is not evaluated on the best possible
configuration, but instead goes for an sub-optimal one. \\
This is required for the algorithm to be feasible, as the Steiner-tree-like
problem that it has to be solved in order to connect all cluster nodes to
a common sub-root is yet again too complex.

As can be seen in [[autoref:lst:alg:heuristic_obj]], each node close enough to the
cluster is evaluated as a candidate root of the corresponding spanning tree. The
network is then simply built joining the minimum paths between the best of those
and the terminals of the set.

\begin{bigalgorithm}
  \label{lst:alg:heuristic_obj}
  \begin{algorithmic}
    \caption{Approximated objective function}
    \Function{objective\_function}{$C$}
    \State total\_cost = 0
    \ForAll{$c \in C$}
    \State best\_cost = $+\infty$
    \ForAll{$v \in V$ close to $c$}
    \State $T_v = \bigcup_{t \in C} \text{minimum path from } v \text{ to } t$

    \State $\text{cost}_v = \text{cable cost of } T_v + \text{excavation cost of } T_v$
    \If {$\text{cost}_v < \text{best\_cost}$ }
    \State $\text{best\_cost} = \text{cost}_v$
    \EndIf
    \EndFor
    \State total\_cost += best\_cost
    \EndFor
    \State \Return total\_cost
    \EndFunction
  \end{algorithmic}
\end{bigalgorithm}

For now all this approximations are mandatory for the algorithm to be fast
enough to deal with our case of study, but in [[autoref:results-network_design]]
they will prove to be good ones, i.e. to be close to the theoretical optimum.

** Flow balancing optimization
:PROPERTIES:
:CUSTOM_ID: methodology-flow_optimization
:END:

#+BEGIN_SRC org :exports none
  - network structure
    - flow control only viable tuning of the logical network
    - components in deeper focus, mention TBF
  - TBF theory
    - params
    - expected behaviour
    - common practice
  - training approach
    - definition of objective function <~ game theory applied
    - genetic algorithm and/or simulated annhealing
      - why an heuristic ~> dynamic solution hopefully
      - "theory" of the tecnique
#+END_SRC

Previous optimization steps returned a plausible topology for Aachen city access
network.

*** Network structure
As presented in autoref:methodology-network_design, obtained network topology is
organized in a hierarchical tree of switches, whose task is to merge all flows
towards the mainframe.

This structure resembles what was previously described in
autoref:fig:network_tree, and is further detailed in
autoref:fig:simulator_uplink and autoref:fig:simulator_downlink. As shown in
these diagrams, each outgoing flow passes through a [[ac:tbf][TBF]]: this unit controls the
rate of the packets before they enter the transmitting interface, labeled as
``NIC''.

The central network controller will use these [[acp:tbf][TBF]] to give or revoke priority
from a given source, with the ultimate goal of keeping the network balanced.
They will be described in their functioning in upcoming autoref:methodology-tbf.

#+NAME: fig:simulator_downlink
#+BEGIN_SRC plantuml :file ../figures/simulator_downlink.eps :noweb yes
  skinparam nodesep 10
  skinparam ranksep 30
  <<plantuml_skin>>
  left to right direction

  node "DSLAM" as dslam1
  node "DSLAM" as dslam2
  node "DSLAM" as dslam3

  node ROUTER {
  queue "TBF" as ROUTER_tbf1 #f6ff9b
  queue "TBF" as ROUTER_tbf2 #f6ff9b
  queue "TBF" as ROUTER_tbf3 #f6ff9b
  queue "NIC" as ROUTER_queue
  queue "NIC" as interface1
  queue "NIC" as interface2
  queue "NIC" as interface3
  }

  database "Server" as server1
  database "Server" as server2

  node "Mainframe" as mf
  dslam1 <-- interface1
  dslam2 <-- interface2
  dslam3 <-- interface3

  interface1 <-- ROUTER_tbf1
  interface2 <-- ROUTER_tbf2
  interface3 <-- ROUTER_tbf3

  ROUTER_tbf1 <-- ROUTER_queue
  ROUTER_tbf2 <-- ROUTER_queue
  ROUTER_tbf3 <-- ROUTER_queue

  ROUTER_queue <-- mf

  cloud "Public\nInternet" as internet
  mf <-- internet

  internet <-- server1
  internet <-- server2
#+END_SRC

# #+ATTR_LATEX: :width 8cm
#+CAPTION: Logical node structure for downlink traffic.
#+LABEL: fig:simulator_downlink
#+RESULTS[f7f24508cf19d10974b4497651141623c9352779]: fig:simulator_downlink
[[file:../figures/simulator_downlink.eps]]

#+NAME: fig:simulator_uplink
#+BEGIN_SRC plantuml :file ../figures/simulator_uplink.eps :noweb yes
  skinparam nodesep 10
  skinparam ranksep 30
  <<plantuml_skin>>
  left to right direction

  node "DSLAM" as dslam1
  node "DSLAM" as dslam2
  node "DSLAM" as dslam3

  node ROUTER {
  queue "TBF" as ROUTER_tbf #f6ff9b
  queue "NIC" as ROUTER_queue
  queue "NIC" as interface1
  queue "NIC" as interface2
  queue "NIC" as interface3
  }

  database "Server" as server1
  database "Server" as server2

  node "Mainframe" as mf
  dslam1 --> interface1
  dslam2 --> interface2
  dslam3 --> interface3

  interface1 --> ROUTER_tbf
  interface2 --> ROUTER_tbf
  interface3 --> ROUTER_tbf

  ROUTER_tbf --> ROUTER_queue

  ROUTER_queue --> mf

  cloud "Public\nInternet" as internet
  mf --> internet

  internet --> server1
  internet --> server2
#+END_SRC

# #+ATTR_LATEX: :width 8cm
#+CAPTION: Logical node structure for uplink traffic.
#+LABEL: fig:simulator_uplink
#+RESULTS[25dbf7a61220364bf16e96ec79bafc95564a5839]: fig:simulator_uplink
[[file:../figures/simulator_uplink.eps]]

*** Token Bucket Filters
:PROPERTIES:
:CUSTOM_ID: methodology-tbf
:END:

\glsreset{tbf}

The [[ac:tbf][TBF]] is a classless discipline for packet queues that can be put in place to
limit bandwidth and burstiness of data flow.

#+NAME: fig:tbf_diagram
#+BEGIN_SRC asymptote :file ../figures/tbf_diagram.pdf :noweb yes
  <<asymptote_preamble>>

  size(10cm);

  // params
  real r = 1;
  real x = 4*r;

  real token_size = r/4;
  int[] packet_sizes = {3, 2, 1, 3, 2};

  pen highlighter = mediumyellow;
  int n_tokens = 3;

  real tq_height = 5*token_size;
  real tq_padding = r/6;

  // traffic queue
  draw((0, 0) -- (x, 0));
  draw((x, 0) -- (x, 2*r));
  draw((0, 2*r) -- (x, 2*r));

  // token queue
  draw(box((x + r, 3*r), (x + 3*r, 3*r + tq_height)));
  real bar_x = x + r - tq_padding * 2;
  draw((bar_x, 3*r) -- (bar_x, 3*r + tq_height),
       bar=Bars,
       L=Label("Bucket size $b$", align=W));

  // connectors
  draw((x + 2*r, 3*r) -- (x + 2*r, 2*r), arrow=Arrow);
  draw((x, r) -- (x + r, r), arrow=Arrow);

  // circle
  draw(circle((x + 2*r, r), r));

  draw((x + 2*r + r*sin(pi/4), r - r*cos(pi/4)) -- (x + 2*r - r*sin(pi/4), r + r*cos(pi/4)));

  draw(rotate(-45)*Label("1 token", align=NE), (x + 2*r, r));
  draw(rotate(-45)*Label("1 byte", align=SW), (x + 2*r, r));

  // input flows
  draw((-2*r, r) -- (r, r),
       arrow=Arrow,
       L=Label("Input packets", align=N));

  real arrow_l = r;
  draw((x + 2*r, 3*r + tq_height + arrow_l) -- (x + 2*r, 3*r + tq_height - tq_padding),
       arrow=Arrow,
       L=Label("Token generation $\lambda$", align=N, position=BeginPoint));

  // output flow
  draw((x + 2*r + r*sin(pi/4), r - r*cos(pi/4)) -- (x + 2*r + r*tan(pi/4), 0) -- (x + 4.5*r, 0),
       arrow=Arrow,
       L=Label("NIC", align=E, position=EndPoint));

  // draw tokens
  for (int n = 0; n < n_tokens; ++n) {
    real y = 3*r + n * token_size;

    real x1 = x + r + tq_padding;
    real x2 = x + 3*r - tq_padding;

    if (n < packet_sizes[0]) {
      fill(box((x1, y), (x2, y + token_size)), highlighter);
    }
    draw(box((x1, y), (x2, y + token_size)));
  }

  // draw packets
  for (int n = 0; n < packet_sizes.length; ++n) {
    real packet_start = 0;
    for (int j = 0; j < n; ++j) {
      packet_start += packet_sizes[j];
    }

    real x1 = x - packet_start * token_size;
    real x2 = x1 - packet_sizes[n] * token_size;

    real y1 = tq_padding;
    real y2 = 2*r - tq_padding;

    if (n == 0) {
      fill(box((x1, y1), (x2, y2)), highlighter);
    }
    else {
      fill(box((x1, y1), (x2, y2)), lightgrey);
    }

    draw(box((x1, y1), (x2, y2)));
  }
#+END_SRC

#+CAPTION: Packets are forwarded once enough tokens are available in the bucket.
#+ATTR_LATEX: :width 10cm
#+LABEL: fig:tbf_diagram
#+RESULTS[9e9264673e041801d14f8ed7199ab720eb61d8f1]: fig:tbf_diagram
[[file:../figures/tbf_diagram.pdf]]

*** Optimization approach

#+NAME: utility_example
#+BEGIN_SRC asymptote :file ../figures/utility_example.pdf :noweb yes
  <<asymptote_preamble>>

  size(8cm);

  real m = 0.15;
  real deltax = 0.2;
  real xcenter = 0.6;

  real padding = 0.2;
  real xmax = xcenter + 0.6;
  real xmin = 0;

  real ymax = 1;
  real ymin = 0;

  draw((xmin, 0) -- (xmax + padding, 0), arrow=Arrow);
  draw((0, ymin - padding) -- (0, ymax + padding), arrow=Arrow);

  label("$x$", (xmax + padding, 0), align=E);
  label("$y$", (0, ymax + padding), align=N);

  draw((0, 1) -- (xmax, 1), dashed + grey);
  label("$1$", (0, 1), align=W);
  label("$0$", (0, 0), align=W);

  import graph;
  real f(real x) {
    return 1/(1 + ((1-m)/m)^((x - xcenter)/deltax));
  }

  path g = graph(f, xmin, xmax);
  draw(g);

  path p1 = (xcenter + deltax, 0) -- (xcenter + deltax, m);
  draw(p1, grey, arrow=Arrows);
  label("$m$", p1, align=W);

  path p2 = (xcenter + 0, -padding/4) -- (xcenter + deltax, -padding/4);
  draw(p2, grey, arrow=Arrows);
  label("$\Delta x$", p2, align=S);

  path p3 = (xcenter -deltax, 0) -- (xcenter -deltax, 1 - m);
  draw(p3, grey, arrow=Arrows);
  label("$1 - m$", p3, align=W);

  path p4 = (xcenter - deltax, -padding/4) -- (xcenter + 0, -padding/4);
  draw(p4, grey, arrow=Arrows);
  label("$\Delta x$", p4, align=S);

  // path p5 = (xcenter, -padding) -- (xcenter, 1 + padding);
  path p5 = (xcenter, -padding*1.2) -- (xcenter, 0);
  draw(p5, black);
  label("$x_c$", (xcenter, -padding*1.2), align=S);

  dot( (xcenter + deltax, m) );
  dot( (xcenter - deltax, 1-m) );
#+END_SRC

#+CAPTION: Utility function with threshold on $x_{c}$, separating suitable and unsuitable values of $x$.
#+ATTR_LATEX: :width 8cm
#+LABEL: utility_example
#+RESULTS[94d068631332ade2aa3868d1a95e9840b9bed403]: utility_example
[[file:../figures/utility_example.pdf]]

* Results
This chapter follows the what was presented in [[autoref:methodology]] and shows
what can be obtained using those theoretical frameworks and tools.

** Geographical analysis
:PROPERTIES:
:CUSTOM_ID: results-geographical_analysis
:END:

#+BEGIN_SRC org :exports none
  + maps details (whatever): maps only here?
  + graph details
    - number of nodes (building & others)
    - number of edges
    - degree distribution
    - average node distance, population
    - ... anything basically ...
#+END_SRC

In order to obtain a decent map of the city, the two OpenStreetMap datasets
corresponding to buildings and streets of the entire state of North
Rein-Westphalia were downloaded, merged and cropped to remove anything outside
Aachen border. cite:OpenStreetMap

After those operations, the remaining 58305 constructions and 9759 roads were
paired with the population density information and used to draw the map in
autoref:results-geographical_analysis.

#+LABEL: fig:aachen_city_map
#+ATTR_LATEX: :height 4.5in
#+CAPTION: Summary of all Aachen district information we will employ: building, roads positions and population distribution.
[[file:../figures/aachen_citymap.png]]

As can be appreciated in the plot, the data is indeed quite accurate and
suitable for the conversion to an abstract graph with streets as edges and road
crossing as vertices. This procedure was performed using a dedicated library
that took care of all the quirks of OpenStreetMap measures[fn:2]. For example
polygons were considered in contact up to a certain tolerance distance and
everything outside the main connected component was pruned. Moreover all nodes
close to each other less than 20m were merged: this removed many useless details
and lowered the number of variables in the upcoming analysis.

Then each building was assigned residents, i.e. users of our access network,
uniformly with respect to the area population density and building surface, as
was explained in autoref:methodology-geographical_analysis.

To integrate customers information into the road graph, a first attempt was made
where a new vertex was created for every building, but the number of variables
turned out to be too high: it was then made the decision to assign the
inhabitants of the city to the closer road crossing. \\
All long roads were split and forced to be shorter than 200m: this way the
average displacement introduced via this approximation was reduced to just 50m,
tolerable for our purposes.

At the end of this pre-processing phase, the graph is made of 7231 vertices and
9272 edges and its complexity can be handled by our algorithms. \\
A visual representation is given in [[autoref:fig:aachen_city_graph]] that shows the
result of a small part of the city center, as tiny details could not be
otherwise discerned.

#+LABEL: fig:aachen_city_graph
#+ATTR_LATEX: :width 4in
#+CAPTION: City topology is converted into an abstract graph.
[[file:~/Archivi/tesi/figures/aachen_city_graph.png]]

[fn:2] See http://xiaming.me/posts/2016/12/18/process-gis-shapefile-with-graph-tools/

** Network design
:PROPERTIES:
:CUSTOM_ID: results-network_design
:END:

#+BEGIN_SRC org :exports none
  ILP results

  - CPLEX performance on the problem
    + computational time
    + number of branches
    + (ask Massimo in case)
  - show found solution for network
    + analyze performance of found solution (bandwidth, ...)
    + consideration on actual used heuristics
#+END_SRC

As was introduced in autoref:solution-approach, the design procedure is
performed starting from the edge of the network, first positioning [[acp:dslam][DSLAMs]],
then second level routers routers and finally the mainframe.

While the mathematical formulation is the same, each iteration requires
different values for the problem parameters. autoref:optimization_params
collects them all omitting the unnecessary ones, such as the fixed cost of the
single mainframe which is not relevant in our analysis.

It is worth mentioning that the cost per unit $c_r$ is split into two addends,
accounting for the physical device and its connection to the mainframe. The
price and the number of ports of the switching units match the most popular
items in the market and industry best practices. cite:CiscoWAN

#+NAME: optimization_params
#+CAPTION: Values for problem parameters in the first two iterations.
#+ATTR_LATEX: :align crrr
| Parameters     |        [[ac:dslam][DSLAM]] |       Routers | Mainframe |
|----------------+--------------+---------------+-----------|
| $n_M$ [unit]   |           48 |           400 | -         |
| $d_M$ [m]      |         1500 |             - | -         |
| $c_r$ [€/unit] | 1000 + 30000 | 15000 + 85000 | -         |
| $c_f$ [€/m]    |            3 |             3 | 3         |
| $c_e$ [€/m]    |          100 |           100 | 100       |

As anticipated in autoref:methodology-network_design the exact
solution to the placement optimization problems could not be obtained using [[ac:ilp][ILP]].
Even with a commercial software such as CPLEX cite:Cplex, in fact, computational
time and memory demand exceeded all resources available.

Although not conclusive, the solver provided useful insights on the valid
solution domain, specifically a lower bound for the objective function. These
limits are then compared against the configuration obtained via heuristic
algorithm, presented before in autoref:methodology-heuristic. \\
[[autoref:solution_table]] clearly shows that the heuristic result is indeed
remarkably close to the theoretical optimum and proves that the choices and
approximations made previously indeed captured all relevant features of the
problem.

#+NAME: solution_table
#+CAPTION: Cost of heuristic solution is compared to the theoretical limit given by [[ac:ilp][ILP]].
#+ATTR_LATEX: :align crr
| Problem                   | [[ac:dslam][DSLAM]] | 2nd level routers |
|---------------------------+-------+-------------------|
| Number of groups          |  1115 |                70 |
| [[ac:ilp][ILP]] cost lower bound [M€] | 65.05 |             38.08 |
| Heuristic cost [M€]       | 67.73 |             39.40 |
| Heuristic gap             |    4% |                3% |
#+TBLFM: @5$2='(format "%d%% "(truncate (* 100 (/ (float (- @4$2 @3$2)) @3$2))));N::@5$3='(format "%d%% "(truncate (* 100 (/ (float (- @4$3 @3$3)) @3$3))));N

A visual representation of the obtained clusters, groups of devices connected to
the same switching unit, is given in [[autoref:fig:heuristic_result]] and in
autoref:fig:heuristic_mainframe. Again the map is cropped in order to scale at
the proper level of detail if needed.

\begin{figure}[htp]
  \captionsetup[subfigure]{skip=-15pt}
  \centering
  \begin{subfigure}[b]{0.48\textwidth}
    \includegraphics[width=\textwidth]{../figures/heuristic_DSLAM.png}
    \caption{DSLAM positioning}
  \end{subfigure}
  \begin{subfigure}[b]{0.48\textwidth}
    \includegraphics[width=\textwidth]{../figures/heuristic_2router.png}
    \caption{Second level routers positioning}
  \end{subfigure}
  \caption{The root nodes in red are hubs for terminals, black points.}
  \label{fig:heuristic_result}
\end{figure}

#+LABEL: fig:heuristic_mainframe
#+ATTR_LATEX: :height 4.5in
#+CAPTION: The mainframe, red dot, is located in an industrial complex and is connected to all second level routers.
[[file:~/Archivi/tesi/figures/heuristic_mainframe.png]]

* Conclusions

bibliographystyle:plain
bibliography:biblio.bib

* COMMENT Local variables
# Local Variables:
# org-latex-tables-booktabs: t
# eval: (flyspell-mode)
# ispell-local-dictionary: "en"
# End:
