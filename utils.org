* Imports and defaults settings
  All imports should be gathered here.

  #+NAME: imports
  #+BEGIN_SRC python
    import csv
    import json
    import math
    from math import sqrt
    from pathlib import Path

    import fiona
    import geopandas as gpd
    import matplotlib.pyplot as plt
    import networkx as nx
    import numpy as np
    import pandas as pd
    from matplotlib import rcParams
    from networkx.readwrite import json_graph, read_graphml
    from pyproj import Proj
    from s2g import ShapeGraph
    from shapely import wkt
    from shapely.geometry import LineString, Point, shape
    from shapely.geometry.polygon import Polygon
    from shapely.ops import cascaded_union, nearest_points

    print('LOG: import ok')
  #+END_SRC

  Default settings for ~matplotlib~.

  #+NAME: matplotlib_defaults
  #+BEGIN_SRC python
    font_spec = {
        'font.family':'sans-serif',
        'font.sans-serif':['Fira Sans'],
        'font.weight': 'regular'
    }
    rcParams.update(font_spec)

    print('LOG: matplotlib ok')
  #+END_SRC

  #+NAME: imports_&_defaults
  #+BEGIN_SRC python :noweb yes
    <<imports>>
    <<matplotlib_defaults>>
  #+END_SRC

* Datasets reading routines
  Read district map and its projection details.

  #+NAME: districts
  #+BEGIN_SRC python
    district_map = gpd.read_file("data/citymap/aachen_district_map.shp")
    del district_map['FLÃ¤cHE'] # whole zero column

    print('LOG: districts ok')
  #+END_SRC


  Read district map projection, used as default one across the computations.
  See [[https://gis.stackexchange.com/questions/17341/projection-pyproj-puzzle-and-understanding-srs-format][here]] for getting projection from ~prj~ file.

  #+NAME: projection
  #+BEGIN_SRC python
    prj_string_file = Path("data/citymap/aachen_district_map_prj.txt")
    if not prj_string_file.is_file():
        import osr # troublesome to install in cluster

        prj_content = open('data/citymap/aachen_district_map.prj', 'r').read()
        srs = osr.SpatialReference()
        srs.ImportFromWkt(prj_content)

        with open(str(prj_string_file), 'w') as f:
            f.write(srs.ExportToProj4())

    prj_string = open(str(prj_string_file), 'r').read()
    projection = Proj(prj_string)

    print('LOG: projection ok')
  #+END_SRC

  Read population statistics for each district and join them to the district ~GeoDataFrame~.

  #+NAME: population
  #+BEGIN_SRC python
    district_population = pd.read_csv("data/citymap/20170630_population_density.csv")
    district_population.columns = ['STATBEZ', 'PERS']

    # join using index
    district_map.set_index('STATBEZ', inplace=True)
    district_population.set_index('STATBEZ', inplace=True)

    district_map['population'] = district_population['PERS']

    # compute area in km^2: I checked some in wikipedia to be sure
    district_map['area'] = district_map['geometry'].area / 10**6
    district_map['density'] = district_map['population'] / district_map['area']

    print('LOG: population ok')
  #+END_SRC

  Read all roads and buildings that are either of ~None~ type or member of this group.
  #+NAME: valid_types
  | house            |
  | residential      |
  | apartments       |
  | industrial       |
  | school           |
  | farm             |
  | retail           |
  | allotment_house  |
  | warehouse        |
  | office           |
  | public           |
  | civic            |
  | hospital         |
  | university       |
  | manufacture      |
  | dormitory        |
  | community_centre |
  | hotel            |
  | bungalow         |
  | family_house     |
  | commercial       |

  #+NAME: roads
  #+BEGIN_SRC python
    roads_path = "data/citymap/aachen_roads.shp"
    roads_map = gpd.read_file(roads_path)
    roads_map.OSM_ID = pd.to_numeric(roads_map.OSM_ID)
    roads_map.crs = {'init': 'epsg:4326'}
    roads_map = roads_map.to_crs(projection.srs)

    print('LOG: roads ok')
  #+END_SRC

  #+NAME: buildings
  #+BEGIN_SRC python
    buildings_path = "data/citymap/aachen_buildings.shp"
    buildings_map = gpd.read_file(buildings_path)
    buildings_map.OSM_ID = pd.to_numeric(buildings_map.OSM_ID)
    buildings_map.crs = {'init': 'epsg:4326'}
    buildings_map = buildings_map.to_crs(projection.srs)

    # set a custom label instead of None
    buildings_map.loc[buildings_map['TYPE'].isnull(), 'TYPE'] = "UNSET"

    # remove unwanted types, but keep UNSET ones
    valid_types = list(np.array(valid_types).flatten()) # flatten Org table
    buildings_map = buildings_map[buildings_map['TYPE'].isin(valid_types + ['UNSET'])]

    print('LOG: buildings ok')
  #+END_SRC

  #+NAME: all_datasets
  #+BEGIN_SRC python :noweb yes :var valid_types=valid_types
    <<imports_&_defaults>>
    <<projection>>
    <<districts>>
    <<population>>
    <<roads>>
    <<buildings>>
  #+END_SRC

* Cluster utilities
  Here comes an handy job file for cluster execution.
  Just replace the script with the one you want to run.

  #+BEGIN_SRC bash :tangle scripts/citymap.job
    #!/bin/bash

    # create ouput files in job directory
    #$ -o /home/lovisott/master_thesis/out.txt
    #$ -e /home/lovisott/master_thesis/err.txt

    cd /home/lovisott/master_thesis/

    source venv/bin/activate
    GDAL_DATA=/home/lovisott/gdal python scripts/citymap/7_get_closest_roads.py
  #+END_SRC

* COMMENT Local variables
  # Local Variables:
  # eval: (add-hook 'before-save-hook (lambda () (indent-region (point-min) (point-max) nil)) t t)
  # End:
