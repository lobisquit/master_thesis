#+PROPERTY: header-args :mkdirp yes

* Retrieve datasets
  Download all needed files from Aachen city repository.

  #+NAME: population_density
  http://offenedaten.aachen.de/dataset/81650028-ef21-4f1b-a991-9e3a3f01c729/resource/460bfe18-7df4-49fb-b5d0-6dfc1d0cffd5/download/20170630opendataaachen-daten-statistische-bezirkealle.csv

  #+NAME: district_map
  http://offenedaten.aachen.de/dataset/5ea893af-8f1d-4658-9066-8f05daed1022/resource/6dfc1b81-26d9-4ed8-b8c4-a61013659f51/download/statistischebezirkeaachen.zip

  For the roads details, see [[https://simonb83.github.io/making-a-map-in-matplotlib.html][here]].
  #+NAME: NRW_map
  http://download.geofabrik.de/europe/germany/nordrhein-westfalen-latest-free.shp.zip

  #+BEGIN_SRC bash :var population_density=population_density district_map=district_map NRW_map=NRW_map :results none :tangle scripts/citymap/1_download.sh
    mkdir -p data/citymap/

    # download
    wget -c $population_density -O data/citymap/20170630_population_density_temp.csv
    wget -c $district_map -O data/citymap/district_map.zip
    wget -c $NRW_map -O data/citymap/NRW_map.zip

    # preprocess
    awk -F, '{print $1 "," $3}' data/citymap/20170630_population_density_temp.csv > data/citymap/20170630_population_density.csv
    rm -f data/citymap/20170630_population_density_temp.csv

    # gather city district borders
    unzip -p data/citymap/district_map.zip StatistischeBezirkeAachen.shp > data/citymap/aachen_district_map.shp
    unzip -p data/citymap/district_map.zip StatistischeBezirkeAachen.shx > data/citymap/aachen_district_map.shx
    unzip -p data/citymap/district_map.zip StatistischeBezirkeAachen.dbf > data/citymap/aachen_district_map.dbf
    unzip -p data/citymap/district_map.zip StatistischeBezirkeAachen.prj > data/citymap/aachen_district_map.prj

    # gather NRW roads
    unzip -p data/citymap/NRW_map.zip gis_osm_roads_free_1.shp > data/citymap/NRW_roads.shp
    unzip -p data/citymap/NRW_map.zip gis_osm_roads_free_1.shx > data/citymap/NRW_roads.shx
    unzip -p data/citymap/NRW_map.zip gis_osm_roads_free_1.dbf > data/citymap/NRW_roads.dbf

    # gather NRW buildings
    unzip -p data/citymap/NRW_map.zip gis_osm_buildings_a_free_1.shp > data/citymap/NRW_buildings.shp
    unzip -p data/citymap/NRW_map.zip gis_osm_buildings_a_free_1.shx > data/citymap/NRW_buildings.shx
    unzip -p data/citymap/NRW_map.zip gis_osm_buildings_a_free_1.dbf > data/citymap/NRW_buildings.dbf
  #+END_SRC

  Initialize the datasets, moving everything in the same projection coordinates.
  See [[https://gis.stackexchange.com/questions/17341/projection-pyproj-puzzle-and-understanding-srs-format][here]] for getting projection from ~prj~ file.

  #+NAME: init_district_map
  #+BEGIN_SRC python :results none :noweb yes
    <<init>>

    # read district map and its projection details
    district_map = gpd.read_file("data/citymap/aachen_district_map.shp")
    del district_map['FLäcHE'] # whole zero column
  #+END_SRC

* Create city map
  Put all relevant NRW data inside a ~postgresql~ database with ~postgis~ extension installed.
  Database is run localy as normal user inside a proper socket directory.

  See [[https://simonb83.github.io/making-a-map-in-matplotlib.html][here]] for details on moving ~shp~ to ~postgresql~.

  #+NAME: socket_dir
  - $(pwd)/data/citymap/postgres/socket_dir/

  #+BEGIN_SRC bash :results none :tangle scripts/citymap/2_postgres_init.sh :var socket_dir=socket_dir
    # create and start local postgres session
    mkdir -p data/citymap/postgres/
    initdb -D data/citymap/postgres/

    mkdir -p $socket_dir
    postgres -D data/citymap/postgres/ -k $socket_dir &

    dropdb nrw -h $socket_dir
    createdb nrw -h $socket_dir
    psql nrw -c 'CREATE EXTENSION postgis' -h $socket_dir

    echo "WARNING: this takes some time..."

    shp2pgsql -s 4326 data/citymap/NRW_roads.shp roads | psql nrw -h $socket_dir > /dev/null
    shp2pgsql -s 4326 data/citymap/NRW_buildings.shp buildings | psql nrw -h $socket_dir > /dev/null
  #+END_SRC

** Retrieve city border
   Extract the union of Aachen metropolitan area, in order to filter roads properly.

   #+BEGIN_SRC python :results none :noweb yes :tangle scripts/citymap/3_city_border.py
     <<init_district_map>>

     with open('data/citymap/aachen_border.txt', 'w') as outfile:
         # extract border
         aachen_area = cascaded_union(district_map['geometry'])

         # convert back to (lat, long) for this purpose
         aachen_area = Polygon([projection(*coord[0:2], inverse=True) \
                                for coord in aachen_area.exterior.coords])

         # convert border from 3D to 2D
         outfile.write(aachen_area.to_wkt())
   #+END_SRC

** City area extraction
   Create output ~shp~ for roads and buildings as normal user using the following queries.

   #+NAME: roads_query
   #+BEGIN_SRC sql
     SELECT osm_id, geom FROM roads
      WHERE fclass NOT IN ('trunk_link', 'bridleway', 'motorway',
                           'motorway_link', 'path', 'primary_link',
                           'secondary_link', 'service', 'steps',
                           'tertiary_link', 'track', 'track_grade2',
                           'track_grade3', 'track_grade4', 'track_grade5',
                           'unclassified', 'unknown')
        AND ST_Intersects(geom, ST_SetSRID(ST_GeomFromText('$aachen_border'), 4326));
   #+END_SRC

   #+NAME: buildings_query
   #+BEGIN_SRC sql
     SELECT osm_id, geom FROM buildings
      WHERE ST_Intersects(geom, ST_SetSRID(ST_GeomFromText('$aachen_border'), 4326));
   #+END_SRC

   #+BEGIN_SRC bash :noweb yes :results output :tangle scripts/citymap/4_extraction.sh
     # extract roads around aachen border
     read aachen_border < data/citymap/aachen_border.txt

     pgsql2shp -f data/citymap/aachen_roads -h localhost -u postgres roads "
                 <<roads_query>>"

     pgsql2shp -f data/citymap/aachen_roads -h localhost -u postgres buildings "
                 <<buildings_query>>"
   #+END_SRC

** Plot population density on the map
   Create final plot, with roads as well as population density.

   #+BEGIN_SRC python :results none :noweb yes :tangle scripts/citymap/5_plot_map.py
     <<init_district_map>>
     <<matplotlib_defaults>>

     # read roads map and move it to district projection
     roads_map = gpd.read_file("data/citymap/aachen_roads.shp")
     roads_map.crs = {'init': 'epsg:4326'}
     roads_map = roads_map.to_crs(projection.srs)

     district_population = pd.read_csv("data/citymap/20170630_population_density.csv")
     district_population.columns = ['STATBEZ', 'PERS']

     # join using index
     district_map.set_index('STATBEZ', inplace=True)
     district_population.set_index('STATBEZ', inplace=True)

     district_map['population'] = district_population['PERS']

     # compute area in km^2: I checked some in wikipedia to be sure
     district_map['area'] = district_map['geometry'].area / 10**6
     district_map['density'] = district_map['population'] / district_map['area']

     fig = plt.figure(figsize=(6, 6), frameon=False)
     ax = fig.gca()

     ax.set_title("Population density in Aachen\n",
                  fontsize=15,
                  fontweight=font_spec['font.weight'])

     district_map.plot(column='density',
                       cmap='viridis',
                       legend=True,
                       linewidth=0, # remove districts borders
                       alpha=0.8,
                       ax=ax)

     roads_map.plot(color='black', linewidth=0.15, ax=ax)

     # set title of colorbar (dirty trick)
     fig.get_axes()[1].set_title('    people/km²',
                                 fontweight=font_spec['font.weight'])

     plt.axis('off')
     plt.tight_layout(rect=[-1.25, -0.04, 1.2, 1])
     plt.savefig('figures/citymap.pdf')

     plt.close('all')
   #+END_SRC

* Create graph from city roads
  Output graph will be saved in ~json~ format.
  See [[https://github.com/caesar0301/s2g][here]] for details on the ~s2g~ library used for conversion.

  #+BEGIN_SRC python :tangle scripts/citymap/6_roads_graph.py
    import json
    from math import sqrt

    import fiona
    import networkx as nx
    from networkx.readwrite import json_graph
    from s2g import ShapeGraph
    from shapely.geometry import LineString, shape

    path = 'data/citymap/aachen_roads.shp'
    # path = '/home/enrico/Scaricati/gis_osm_roads_free_1.shp' # test path

    sg = ShapeGraph(shapefile=path, to_graph=True)

    # convert graph to json
    G = json_graph.node_link_data(sg.graph)

    for node in G['nodes']:
        node['lat'], node['long'] = sg.node_xy[node['id']]

    with open('data/citymap/connected_roads.json', 'w') as output:
        output.write(json.dumps(G))
  #+END_SRC

  Here comes an handy job file for cluster execution.

  #+BEGIN_SRC bash :tangle scripts/citymap.job
    #!/bin/bash

    # create ouput files in job directory
    #$ -o ~/master_thesis/out_simulation.txt
    #$ -e ~/master_thesis/err_simulation.txt

    cd ~/master_thesis/

    source venv/bin/activate
    python scripts/citymap/6_roads_graph.py
  #+END_SRC

  #+BEGIN_SRC python :tangle scripts/citymap/7_graph_analysis.py :results none :noweb yes
    <<init>>
    <<matplotlib_defaults>>

    with open('data/citymap/connected_roads.json', 'r') as f:
        graph_data = json.load(f)

    G = json_graph.node_link_graph(graph_data)
    nodes = G.nodes(data=True)

    # build a gpd GeoDataFrame for nodes
    nodes_info = []
    for id_, data in nodes:
        point = Point(data['lat'], data['long'])
        nodes_info.append({'id': id_, 'geometry': point})

    nodes_df = gpd.GeoDataFrame(nodes_info)
    nodes_df.crs = {'init' :'epsg:4326'} # long-lat projection
    nodes_df = nodes_df.to_crs(projection.srs)

    # build a gpd GeoDataFrame for edges
    edges_info = []
    for node_id1, node_id2, data in G.edges(data=True):
        edge = LineString((
            (nodes[node_id1]['lat'], nodes[node_id1]['long']),
            (nodes[node_id2]['lat'], nodes[node_id2]['long'])
        ))

        edges_info.append({'geometry': edge, **data})

    edges_df = gpd.GeoDataFrame(edges_info)
    edges_df.crs = {'init' :'epsg:4326'} # long-lat projection
    edges_df = edges_df.to_crs(projection.srs)

    # plot the one on top of the other
    fig = plt.figure(figsize=(6, 6), frameon=False)
    ax = fig.gca()

    ax.set_title("Graph of city roads\n",
                 fontsize=15,
                 fontweight=font_spec['font.weight'])

    nodes_df.plot(ax=ax,
                  markersize=0.05,
                  color='black',
                  zorder=2)

    edges_df.plot(ax=ax,
                  color='black',
                  # column='weight',
                  # linewidth=0.3,
                  zorder=1)

    plt.axis('off')
    plt.tight_layout(rect=[-0.1, -0.05, 1.1, 1])
    # plt.show()
    plt.savefig('figures/citymap-graph.pdf')
    plt.close('all')

  #+END_SRC

* Local variables
  # Local Variables:
  # eval: (add-hook 'before-save-hook (lambda () (indent-region (point-min) (point-max) nil)) t t)
  # eval: (org-babel-lob-ingest "utils.org")
  # End:
