#+PROPERTY: header-args :mkdirp yes

* Retrieve datasets
  Download all needed files from Aachen city repository.

  #+NAME: population_density_link
  http://offenedaten.aachen.de/dataset/81650028-ef21-4f1b-a991-9e3a3f01c729/resource/460bfe18-7df4-49fb-b5d0-6dfc1d0cffd5/download/20170630opendataaachen-daten-statistische-bezirkealle.csv

  #+NAME: district_map_link
  http://offenedaten.aachen.de/dataset/5ea893af-8f1d-4658-9066-8f05daed1022/resource/6dfc1b81-26d9-4ed8-b8c4-a61013659f51/download/statistischebezirkeaachen.zip

  #+NAME: NRW_map_link
  http://download.geofabrik.de/europe/germany/nordrhein-westfalen-latest-free.shp.zip
  For the roads details, see [[https://simonb83.github.io/making-a-map-in-matplotlib.html][here]].

  #+BEGIN_SRC bash :var population_density=population_density_link district_map=district_map_link NRW_map=NRW_map_link :results none :tangle scripts/citymap/1_download.sh
    mkdir -p data/citymap/

    # download
    wget -c $population_density -O data/citymap/20170630_population_density_temp.csv
    wget -c $district_map -O data/citymap/district_map.zip
    wget -c $NRW_map -O data/citymap/NRW_map.zip

    # preprocess
    awk -F, '{print $1 "," $3}' data/citymap/20170630_population_density_temp.csv > data/citymap/20170630_population_density.csv
    rm -f data/citymap/20170630_population_density_temp.csv

    # gather city district borders
    unzip -p data/citymap/district_map.zip StatistischeBezirkeAachen.shp > data/citymap/aachen_district_map.shp
    unzip -p data/citymap/district_map.zip StatistischeBezirkeAachen.shx > data/citymap/aachen_district_map.shx
    unzip -p data/citymap/district_map.zip StatistischeBezirkeAachen.dbf > data/citymap/aachen_district_map.dbf
    unzip -p data/citymap/district_map.zip StatistischeBezirkeAachen.prj > data/citymap/aachen_district_map.prj

    # gather NRW roads
    unzip -p data/citymap/NRW_map.zip gis_osm_roads_free_1.shp > data/citymap/NRW_roads.shp
    unzip -p data/citymap/NRW_map.zip gis_osm_roads_free_1.shx > data/citymap/NRW_roads.shx
    unzip -p data/citymap/NRW_map.zip gis_osm_roads_free_1.dbf > data/citymap/NRW_roads.dbf

    # gather NRW buildings
    unzip -p data/citymap/NRW_map.zip gis_osm_buildings_a_free_1.shp > data/citymap/NRW_buildings.shp
    unzip -p data/citymap/NRW_map.zip gis_osm_buildings_a_free_1.shx > data/citymap/NRW_buildings.shx
    unzip -p data/citymap/NRW_map.zip gis_osm_buildings_a_free_1.dbf > data/citymap/NRW_buildings.dbf
  #+END_SRC

* Create city map
  Put all relevant NRW data inside a ~postgresql~ database with ~postgis~ extension installed.
  Database is run localy as normal user inside a proper socket directory.

  See [[https://simonb83.github.io/making-a-map-in-matplotlib.html][here]] for details on moving ~shp~ to ~postgresql~.

  #+NAME: socket_dir
  - data/citymap/postgres/socket_dir/

  #+BEGIN_SRC bash :results none :tangle scripts/citymap/2_postgres_init.sh :var socket_dir=socket_dir
    # create and start local postgres session
    mkdir -p data/citymap/postgres/
    initdb -D data/citymap/postgres/

    mkdir -p $(pwd)/$socket_dir
    postgres -D data/citymap/postgres/ -k $(pwd)/$socket_dir &

    dropdb nrw -h $(pwd)/$socket_dir
    createdb nrw -h $(pwd)/$socket_dir
    psql nrw -c 'CREATE EXTENSION postgis' -h $(pwd)/$socket_dir

    echo "WARNING: this takes some time..."

    shp2pgsql -s 4326 data/citymap/NRW_roads.shp roads | psql nrw -h $(pwd)/$socket_dir > /dev/null
    shp2pgsql -s 4326 data/citymap/NRW_buildings.shp buildings | psql nrw -h $(pwd)/$socket_dir > /dev/null
  #+END_SRC

** Retrieve city border
   Extract the union of Aachen metropolitan area, in order to filter roads properly.

   #+BEGIN_SRC python :results none :noweb yes :tangle scripts/citymap/3_city_border.py
     <<imports_&_defaults>>
     <<districts>>

      with open('data/citymap/aachen_border.txt', 'w') as outfile:
          # extract border
          aachen_area = cascaded_union(district_map['geometry'])

          # convert back to (lat, long) for this purpose
          aachen_area = Polygon([projection(*coord[0:2], inverse=True) \
                                 for coord in aachen_area.exterior.coords])

          # convert border from 3D to 2D
          outfile.write(aachen_area.to_wkt())
   #+END_SRC

** Extract city information
   Create output ~shp~ for roads and buildings using the following queries.

   #+NAME: roads_query
   #+BEGIN_SRC sql
     SELECT osm_id, geom FROM roads
      WHERE fclass NOT IN ('trunk_link', 'bridleway', 'motorway',
                           'motorway_link', 'path', 'primary_link',
                           'secondary_link', 'service', 'steps',
                           'tertiary_link', 'track', 'track_grade2',
                           'track_grade3', 'track_grade4', 'track_grade5',
                           'unclassified', 'unknown')
        AND ST_Intersects(geom, ST_SetSRID(ST_GeomFromText('$aachen_border'), 4326));
   #+END_SRC

   #+NAME: buildings_query
   #+BEGIN_SRC sql
     SELECT osm_id, geom, type FROM buildings
      WHERE ST_Intersects(geom, ST_SetSRID(ST_GeomFromText('$aachen_border'), 4326));
   #+END_SRC

   #+BEGIN_SRC bash :noweb yes :results output :tangle scripts/citymap/4_extraction.sh :var socket_dir=socket_dir
     # extract roads around aachen border
     read aachen_border < data/citymap/aachen_border.txt

     # due to noweb shortcomings, first newline and leading whitespaces have to be removed
     query="
            <<roads_query>>"
     pgsql2shp -f data/citymap/aachen_roads -h $(pwd)/$socket_dir nrw \
               "$(echo ${query:1:${#query}} | sed 's/^[\t ]*//g')"

     query="
            <<buildings_query>>"
     pgsql2shp -f data/citymap/aachen_buildings -h $(pwd)/$socket_dir nrw \
               "$(echo ${query:1:${#query}} | sed 's/^[\t ]*//g')"
   #+END_SRC

** Plot the map
   Create final plot, with roads as well as population density.

   #+BEGIN_SRC python :results none :noweb yes :tangle scripts/citymap/5_plot_map.py :var valid_types=utils.org:valid_types
     <<all_datasets>>

     fig = plt.figure(figsize=(6, 6), frameon=False)
     ax = fig.gca()

     ax.set_title("Population density in Aachen\n",
                  fontsize=15,
                  fontweight=font_spec['font.weight'])

     district_map.plot(column='density',
                       cmap='viridis',
                       legend=True,
                       linewidth=0, # remove districts borders
                       alpha=0.7,
                       ax=ax)

     roads_map.plot(color='black',
                    alpha=0.6,
                    linewidth=0.15,
                    ax=ax)

     buildings_map.plot(color='black',
                        alpha=0.5,
                        linewidth=0.15,
                        ax=ax)

     # set title of colorbar (dirty trick)
     fig.get_axes()[1].set_title('    people/kmÂ²',
                                 fontweight=font_spec['font.weight'])

     plt.axis('off')
     plt.tight_layout(rect=[-1.25, -0.04, 1.2, 1])

     # plt.show()

     plt.savefig('figures/citymap.pdf')
     plt.close('all')
   #+END_SRC

* Create graph from city roads
** Create an abstract graph from the roads
   When creating the graph, remember ~OSM_ID~, in order to assign each building a proper edge.

   #+NAME: graph_path
   - data/citymap/connected_roads.json

   #+BEGIN_SRC python :noweb yes :var valid_types=utils.org:valid_types :var graph_path=graph_path :tangle scripts/citymap/7_get_roads_graph.py
     <<imports_&_defaults>>
     <<roads>>
     <<buildings>>

     sg = ShapeGraph(shapefile=roads_path, to_graph=True, properties=['OSM_ID'])

     # convert graph to json
     G = json_graph.node_link_data(sg.graph)

     for node in G['nodes']:
         node['lat'], node['lon'] = sg.node_xy[node['id']]

     # use of private variable seems to be mandatory here
     edge_osm_id_map = {
         edge: sg.line_info(info.line_index).props['OSM_ID']
         for edge, info in sg._edges.items() if info.line_index is not None
     }

     for edge in G['edges']:
         if edge in edge_osm_id_map:
             G[edge[0]][edge[1]]['OSM_ID'] = edge_osm_id_map[edge]

     with open(graph_path[0][0], 'w') as output:
         output.write(json.dumps(G))
   #+END_SRC

** Match each building with the closest road
   Find the closest road on the map for each house, in order to set the house as a node on the road graph.
   This has to consider only roads in the major component of the city, not the unconnected ones.

   #+NAME: closest_roads_path
   - data/citymap/closest_roads.csv

   #+BEGIN_SRC python :noweb yes :tangle scripts/citymap/6_get_closest_roads.py :var valid_types=utils.org:valid_types :var closest_roads_path=closest_roads_path :var graph_path=graph_path
     <<imports_&_defaults>>
     <<roads>>
     <<buildings>>

     # compute minimum distance between each building and the roads
     def nearest_road(building, roads_map):
         road_index = roads_map.geometry.distance(building.geometry).values.argmin()
         return pd.Series([building.OSM_ID, roads_map.iloc[road_index].OSM_ID],
                          index=['building_OSM_ID', 'road_OSM_ID'])

     # load graph
     with open(graph_path[0][0]) as f:
         js_graph = json.load(f)

     G = json_graph.node_link_graph(js_graph)

     # load roads in graph major component
     valid_road_osm_ids = set(
         [data['OSM_ID'] for _, _, data in G.edges(data=True) if 'OSM_ID' in data]
     )
     valid_roads = roads_map[roads_map.OSM_ID.isin(valid_road_osm_ids)]

     # filter them
     closest_roads = buildings_map.apply(
         lambda row: nearest_road(row, valid_roads),
         axis=1
     )

     closest_roads.to_csv(closest_roads_path[0][0], index=None)
   #+END_SRC

** Project each building on its road
   The graph is filled with buildings, replacing each edge
   with two edges, with the building node in the middle.

   Use projected point of the building on the road point as actual position:
   line is supposed to be payed by the customer from the road to the home,
   so there is no cost for the operator.

   #+BEGIN_SRC python :noweb yes :var valid_types=utils.org:valid_types :var graph_path=graph_path :var closest_roads_path=closest_roads_path :tangle scripts/citymap/8_add_buildings_to_graph.py
     <<all_datasets>>

     # read graph G
     with open(graph_path[0][0]) as f:
         js_graph = json.load(f)

     G = json_graph.node_link_graph(js_graph)

     closest_roads = pd.read_csv(closest_roads_path[0][0])

     buildings_map.set_index('OSM_ID', inplace=True)
     roads_map.set_index('OSM_ID', inplace=True)

     # TODO remove buildings too far from the road
     dists = []
     for i, (b_ID, r_ID) in closest_roads.iterrows():
         # print(b_ID, r_ID)
         road = roads_map.loc[r_ID].geometry
         building = buildings_map.loc[b_ID].geometry
         d = road.distance(building)
         dists.append(d)

     # TODO build proper dictionary for efficiency
     osm_id_edge_map = {}

     for _, row in closest_roads.iterrows():
         building = buildings_map.loc[str(row.building_OSM_ID)].geometry
         road = roads_map.loc[str(row.road_OSM_ID)].geometry

         b_point, r_point = nearest_points(building, road)

         # gather population density of the building location
         district_density = 0 # building center is actually outside Aachen
         for _, district_row in district_map.iterrows():
             if building.centroid.within(district_row.geometry):
                 district_density = district_row.density

         # find edge (road) corresponding to given OSM ID
         if row.road_OSM_ID in osm_id_edge_map:
             wanted_edge = osm_id_edge_map[row.road_OSM_ID]
         else:
             raise ValueError(row.road_OSM_ID)

         # remove edge
         x, y, data = wanted_edge
         G.remove_edge(i, j)

         # create node and put it in the middle
         building_attrs = {
             'lat': b_point.coords[0],
             'lon': b_point.coords[1],
             'n_people': building.area * district_density
         }
         G.add_node(row.building_OSM_ID, **building_attrs)
         G.add_edge(x, row.building_OSM_ID)
         G.add_edge(row.building_OSM_ID, y)

     with open(graph_path[0][0].replace('.json', '_complete.json'), 'w') as output:
         output.write(json.dumps(G))
   #+END_SRC


* COMMENT Local variables
  # Local Variables:
  # eval: (add-hook 'before-save-hook (lambda () (indent-region (point-min) (point-max) nil)) t t)
  # eval: (add-hook 'org-babel-pre-tangle-hook (lambda () (org-babel-lob-ingest "utils.org")) t t)
  # End:
