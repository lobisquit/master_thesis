#+PROPERTY: header-args :mkdirp yes

* Retrieve datasets
  Download all needed files from Aachen city repository.

  #+NAME: population_density_link
  http://offenedaten.aachen.de/dataset/81650028-ef21-4f1b-a991-9e3a3f01c729/resource/460bfe18-7df4-49fb-b5d0-6dfc1d0cffd5/download/20170630opendataaachen-daten-statistische-bezirkealle.csv

  #+NAME: district_map_link
  http://offenedaten.aachen.de/dataset/5ea893af-8f1d-4658-9066-8f05daed1022/resource/6dfc1b81-26d9-4ed8-b8c4-a61013659f51/download/statistischebezirkeaachen.zip

  #+NAME: NRW_map_link
  http://download.geofabrik.de/europe/germany/nordrhein-westfalen-latest-free.shp.zip
  For the roads details, see [[https://simonb83.github.io/making-a-map-in-matplotlib.html][here]].

  #+BEGIN_SRC bash :var population_density=population_density_link district_map=district_map_link NRW_map=NRW_map_link :results none :tangle scripts/citymap/1_download.sh
    mkdir -p data/citymap/

    # download
    wget -c $population_density -O data/citymap/20170630_population_density_temp.csv
    wget -c $district_map -O data/citymap/district_map.zip
    wget -c $NRW_map -O data/citymap/NRW_map.zip

    # preprocess
    awk -F, '{print $1 "," $3}' data/citymap/20170630_population_density_temp.csv > data/citymap/20170630_population_density.csv
    rm -f data/citymap/20170630_population_density_temp.csv

    # gather city district borders
    unzip -p data/citymap/district_map.zip StatistischeBezirkeAachen.shp > data/citymap/aachen_district_map.shp
    unzip -p data/citymap/district_map.zip StatistischeBezirkeAachen.shx > data/citymap/aachen_district_map.shx
    unzip -p data/citymap/district_map.zip StatistischeBezirkeAachen.dbf > data/citymap/aachen_district_map.dbf
    unzip -p data/citymap/district_map.zip StatistischeBezirkeAachen.prj > data/citymap/aachen_district_map.prj

    # gather NRW roads
    unzip -p data/citymap/NRW_map.zip gis_osm_roads_free_1.shp > data/citymap/NRW_roads.shp
    unzip -p data/citymap/NRW_map.zip gis_osm_roads_free_1.shx > data/citymap/NRW_roads.shx
    unzip -p data/citymap/NRW_map.zip gis_osm_roads_free_1.dbf > data/citymap/NRW_roads.dbf

    # gather NRW buildings
    unzip -p data/citymap/NRW_map.zip gis_osm_buildings_a_free_1.shp > data/citymap/NRW_buildings.shp
    unzip -p data/citymap/NRW_map.zip gis_osm_buildings_a_free_1.shx > data/citymap/NRW_buildings.shx
    unzip -p data/citymap/NRW_map.zip gis_osm_buildings_a_free_1.dbf > data/citymap/NRW_buildings.dbf
  #+END_SRC

* Create city map
  Put all relevant NRW data inside a ~postgresql~ database with ~postgis~ extension installed.
  Database is run localy as normal user inside a proper socket directory.

  See [[https://simonb83.github.io/making-a-map-in-matplotlib.html][here]] for details on moving ~shp~ to ~postgresql~.

  #+NAME: socket_dir
  - data/citymap/postgres/socket_dir/

  #+BEGIN_SRC bash :results none :tangle scripts/citymap/2_postgres_init.sh :var socket_dir=socket_dir
    # create and start local postgres session
    mkdir -p data/citymap/postgres/
    initdb -D data/citymap/postgres/

    mkdir -p $(pwd)/$socket_dir
    postgres -D data/citymap/postgres/ -k $(pwd)/$socket_dir &

    dropdb nrw -h $(pwd)/$socket_dir
    createdb nrw -h $(pwd)/$socket_dir
    psql nrw -c 'CREATE EXTENSION postgis' -h $(pwd)/$socket_dir

    echo "WARNING: this takes some time..."

    shp2pgsql -s 4326 data/citymap/NRW_roads.shp roads | psql nrw -h $(pwd)/$socket_dir > /dev/null
    shp2pgsql -s 4326 data/citymap/NRW_buildings.shp buildings | psql nrw -h $(pwd)/$socket_dir > /dev/null
  #+END_SRC

** Retrieve city border
   Extract the union of Aachen metropolitan area, in order to filter roads properly.

   #+BEGIN_SRC python :results none :noweb yes :tangle scripts/citymap/3_city_border.py
     <<imports_&_defaults>>
     <<districts>>

      with open('data/citymap/aachen_border.txt', 'w') as outfile:
          # extract border
          aachen_area = cascaded_union(district_map['geometry'])

          # convert back to (lat, long) for this purpose
          aachen_area = Polygon([projection(*coord[0:2], inverse=True) \
                                 for coord in aachen_area.exterior.coords])

          # convert border from 3D to 2D
          outfile.write(aachen_area.to_wkt())
   #+END_SRC

** Extract city information
   Create output ~shp~ for roads and buildings using the following queries.

   #+NAME: roads_query
   #+BEGIN_SRC sql
     SELECT osm_id, geom FROM roads
      WHERE fclass NOT IN ('trunk_link', 'bridleway', 'motorway',
                           'motorway_link', 'path', 'primary_link',
                           'secondary_link', 'service', 'steps',
                           'tertiary_link', 'track', 'track_grade2',
                           'track_grade3', 'track_grade4', 'track_grade5',
                           'unclassified', 'unknown')
        AND ST_Intersects(geom, ST_SetSRID(ST_GeomFromText('$aachen_border'), 4326));
   #+END_SRC

   #+NAME: buildings_query
   #+BEGIN_SRC sql
     SELECT osm_id, geom FROM buildings
      WHERE ST_Intersects(geom, ST_SetSRID(ST_GeomFromText('$aachen_border'), 4326));
   #+END_SRC

   #+BEGIN_SRC bash :noweb yes :results output :tangle scripts/citymap/4_extraction.sh :var socket_dir=socket_dir
     # extract roads around aachen border
     read aachen_border < data/citymap/aachen_border.txt

     # due to noweb shortcomings, first newline and leading whitespaces have to be removed
     query="
            <<roads_query>>"
     pgsql2shp -f data/citymap/aachen_roads -h $(pwd)/$socket_dir nrw \
               "$(echo ${query:1:${#query}} | sed 's/^[\t ]*//g')"

     query="
            <<buildings_query>>"
     pgsql2shp -f data/citymap/aachen_buildings -h $(pwd)/$socket_dir nrw \
               "$(echo ${query:1:${#query}} | sed 's/^[\t ]*//g')"
   #+END_SRC

** Plot the map
   Create final plot, with roads as well as population density.

   #+BEGIN_SRC python :results none :noweb yes :tangle scripts/citymap/5_plot_map.py :var valid_types=utils.org:valid_types
     <<all_datasets>>

     fig = plt.figure(figsize=(6, 6), frameon=False)
     ax = fig.gca()

     ax.set_title("Population density in Aachen\n",
                  fontsize=15,
                  fontweight=font_spec['font.weight'])

     district_map.plot(column='density',
                       cmap='viridis',
                       legend=True,
                       linewidth=0, # remove districts borders
                       alpha=0.7,
                       ax=ax)

     roads_map.plot(color='black',
                    alpha=0.6,
                    linewidth=0.15,
                    ax=ax)

     buildings_map.plot(color='black',
                        alpha=0.5,
                        linewidth=0.15,
                        ax=ax)

     # set title of colorbar (dirty trick)
     fig.get_axes()[1].set_title('    people/kmÂ²',
                                 fontweight=font_spec['font.weight'])

     plt.axis('off')
     plt.tight_layout(rect=[-1.25, -0.04, 1.2, 1])

     # plt.show()

     plt.savefig('figures/citymap.pdf')
     plt.close('all')
   #+END_SRC

* Create graph from city roads
  Output graph will be saved in ~json~ format.
  See [[https://github.com/caesar0301/s2g][here]] for details on the ~s2g~ library used for conversion.

  First, filter buildings based on their type.
  Note that the majority of them is not set, so ~None~ is a valid type.

  #+BEGIN_SRC python :tangle scripts/citymap/6_roads_graph.py :var valid_types=utils.org:valid_types
    import json
    from math import sqrt

    import fiona
    import networkx as nx
    from networkx.readwrite import json_graph
    from s2g import ShapeGraph
    from shapely.geometry import LineString, shape

    path = 'data/citymap/aachen_roads.shp'
    # path = '/home/enrico/Scaricati/gis_osm_roads_free_1.shp' # test path

    # set a custom label instead of None
    buildings_map.loc[buildings_map['TYPE'].isnull(), 'TYPE'] = "UNSET"

    sg = ShapeGraph(shapefile=path, to_graph=True)

    buildings_map = gpd.read_file("data/citymap/aachen_buildings.shp")

    # convert graph to json
    G = json_graph.node_link_data(sg.graph)

    for node in G['nodes']:
        node['lat'], node['long'] = sg.node_xy[node['id']]

    with open('data/citymap/connected_roads.json', 'w') as output:
        output.write(json.dumps(G))
  #+END_SRC

  Here comes an handy job file for cluster execution.

  #+BEGIN_SRC bash :tangle scripts/citymap.job
    #!/bin/bash

    # create ouput files in job directory
    #$ -o ~/master_thesis/out_simulation.txt
    #$ -e ~/master_thesis/err_simulation.txt

    cd ~/master_thesis/

    source venv/bin/activate
    python scripts/citymap/6_roads_graph.py
  #+END_SRC

  #+BEGIN_SRC python :tangle scripts/citymap/7_graph_analysis.py :results none :noweb yes
    <<init_datasets>>
    <<matplotlib_defaults>>

    with open('data/citymap/connected_roads.json', 'r') as f:
        graph_data = json.load(f)

    G = json_graph.node_link_graph(graph_data)
    nodes = G.nodes(data=True)

    # build a gpd GeoDataFrame for nodes
    nodes_info = []
    for id_, data in nodes:
        point = Point(data['lat'], data['long'])
        nodes_info.append({'id': id_, 'geometry': point})

    nodes_df = gpd.GeoDataFrame(nodes_info)
    nodes_df.crs = {'init' :'epsg:4326'} # long-lat projection
    nodes_df = nodes_df.to_crs(projection.srs)

    # build a gpd GeoDataFrame for edges
    edges_info = []
    for node_id1, node_id2, data in G.edges(data=True):
        edge = LineString((
            (nodes[node_id1]['lat'], nodes[node_id1]['long']),
            (nodes[node_id2]['lat'], nodes[node_id2]['long'])
        ))

        edges_info.append({'geometry': edge, **data})

    edges_df = gpd.GeoDataFrame(edges_info)
    edges_df.crs = {'init' :'epsg:4326'} # long-lat projection
    edges_df = edges_df.to_crs(projection.srs)

    # plot the one on top of the other
    fig = plt.figure(figsize=(6, 6), frameon=False)
    ax = fig.gca()

    ax.set_title("Graph of city roads\n",
                 fontsize=15,
                 fontweight=font_spec['font.weight'])

    nodes_df.plot(ax=ax,
                  markersize=0.05,
                  color='black',
                  zorder=2)

    edges_df.plot(ax=ax,
                  color='black',
                  # column='weight',
                  # linewidth=0.3,
                  zorder=1)

    plt.axis('off')
    plt.tight_layout(rect=[-0.1, -0.05, 1.1, 1])
    # plt.show()
    plt.savefig('figures/citymap-graph.pdf')
    plt.close('all')
  #+END_SRC

* Local variables
  # Local Variables:
  # eval: (add-hook 'before-save-hook (lambda () (indent-region (point-min) (point-max) nil)) t t)
  # eval: (add-hook 'org-babel-pre-tangle-hook (lambda () (org-babel-lob-ingest "utils.org")) t t)
  # End:
