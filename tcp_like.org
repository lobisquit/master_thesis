# -*- mode: Org; -*-

#+STARTUP: indent
#+OPTIONS: toc:nil

In order for this protocols to work, each page request has to have

- a request ID unique for the user
- a sequence number P, unique in the session
- a sequence max number L, constant for the session
- routing information (path)
- size
- transmission time, in order to estimate RTT
- a type, for distinguishing between page requests, ACKs, ...

We suppose a on-off user activity process, with exponential off times, 10s mean.

* TCP like protocol
Description of a Go-Back-N ARQ protocol that is similar enough to TCP for our
purposes.

Note that at any time, receiving a request with ID different from the current
one (if any) resets the server to IDLE and the last request is processed.

#+BEGIN_SRC plantuml :file figures/tcp_server_side.png :noweb yes
  <<plantuml_skin>>
  skinparam defaultTextAlignment center
  hide empty description
  state "# set A = -1 \l# set B = 0 \l# estimate RTT based on request packet" as INIT
  state IDLE #f6ff9b
  state "B < A + N + 1?" as DECIDE
  state "compute Round Trip Time \lof the last ACKed packets" as RECV
  state "# transmit packet B + 1 \l# set B = B + 1" as TX
  state "set B = A" as RETX
  state "P = L?" as CHECK_FINISH
  state "IDLE" as FINISH #f6ff9b
  state "A = max{A, P}" as UPDATE_A

  IDLE -> INIT : Page request \n with window size N

  INIT --> DECIDE

  DECIDE --> WAIT : NO
  DECIDE -left> TX : YES

  TX -> DECIDE : Timeout of RTT/2
  TX -> RECV : ACK(P) received

  RETX --> DECIDE

  WAIT -> RETX : Timeout of t<sub>0</sub>
  WAIT --> RECV : ACK(P) received

  RECV -> CHECK_FINISH

  CHECK_FINISH --> FINISH : YES
  CHECK_FINISH -> UPDATE_A : NO

  UPDATE_A --> DECIDE

  legend
  ,* A is the ID of the last packet known to be received by the user
  ,* B is the ID of the last packet sent by the server
  ,* L is the ID of the last packet of current page request
  ,* œÅ is the current (estimated) throughput of the connection
  ,* t<sub>0</sub> is a multiple of the estimated Round Trip Time
  end legend
#+END_SRC

#+RESULTS:
[[file:figures/tcp_server_side.png]]

#+BEGIN_SRC plantuml :file figures/tcp_client_side.png :noweb yes
  <<plantuml_skin>>

  skinparam defaultTextAlignment center
  hide empty description

  state "# Transmit page request\l# Initialize arrived array" as INIT
  state IDLE #f6ff9b
  state ACK_L as "Send ACK(L)"
  state "# estimate RTT on last packets\l# set arrived(P) = True\l# set K=argmin{arrived(i)=False}" as RECV
  state "Send ACK(K)" as SEND_ACK
  state "K = L?" as CHECK_FINISH
  state "IDLE" as FINISH #f6ff9b

  IDLE --> INIT : User requests a page
  IDLE -> ACK_L : Packet P of L arrives

  ACK_L -> IDLE : \n

  INIT -> INIT : Timeout of t<sub>0</sub>
  INIT --> RECV : Packet P of L arrives

  RECV -> SEND_ACK

  SEND_ACK --> CHECK_FINISH

  WAIT --> RECV : \nPacket P of L arrives
  WAIT -> SEND_ACK : Timeout of RTT\n

  CHECK_FINISH --> FINISH : YES
  CHECK_FINISH --> WAIT : NO

  legend
  ,* t<sub>0</sub> is a multiple of the supposed Round Trip Time of the connection
  ,* each data packet contains its ID, P, and the ID of the last one, L
  end legend

#+END_SRC

#+RESULTS:
[[file:figures/tcp_client_side.png]]

* UDP like protocol
Simply send packets with serial number from the server at requested quality
(bitrate). Client side, just compute jitter, throughput and packet losses in a
certain time window based on what arrives: packet losses are easy to calculate
based on serial numbers.

* COMMENT Local variables
# Local Variables:
# org-confirm-babel-evaluate: nil
# eval: (add-hook 'org-babel-pre-tangle-hook (lambda () (org-babel-lob-ingest "thesis/thesis.org")) t t
# eval:  (add-hook 'org-babel-after-execute-hook 'org-display-inline-images)
# End:
