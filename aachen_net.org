#+PROPERTY: header-args :mkdirp yes
#+PROPERTY: header-args:python :shebang "#!/usr/bin/python \n# -*- coding: utf-8 -*-"

* Retrieve datasets
  Download all needed files from Aachen city repository.

  #+NAME: population_density_link
  http://offenedaten.aachen.de/dataset/81650028-ef21-4f1b-a991-9e3a3f01c729/resource/460bfe18-7df4-49fb-b5d0-6dfc1d0cffd5/download/20170630opendataaachen-daten-statistische-bezirkealle.csv

  #+NAME: district_map_link
  http://offenedaten.aachen.de/dataset/5ea893af-8f1d-4658-9066-8f05daed1022/resource/6dfc1b81-26d9-4ed8-b8c4-a61013659f51/download/statistischebezirkeaachen.zip

  #+NAME: NRW_map_link
  http://download.geofabrik.de/europe/germany/nordrhein-westfalen-latest-free.shp.zip

  For the roads details, see [[https://simonb83.github.io/making-a-map-in-matplotlib.html][here]].

  #+BEGIN_SRC bash :var population_density=population_density_link district_map=district_map_link NRW_map=NRW_map_link :results none :tangle scripts/aachen_net/01_download.sh
    mkdir -p data/aachen_net/

    # download
    wget -c $population_density -O data/aachen_net/20170630_population_density_temp.csv
    wget -c $district_map -O data/aachen_net/district_map.zip
    wget -c $NRW_map -O data/aachen_net/NRW_map.zip

    # preprocess
    awk -F, '{print $1 "," $3}' data/aachen_net/20170630_population_density_temp.csv > data/aachen_net/20170630_population_density.csv
    rm -f data/aachen_net/20170630_population_density_temp.csv

    # gather city district borders
    unzip -p data/aachen_net/district_map.zip StatistischeBezirkeAachen.shp > data/aachen_net/aachen_district_map.shp
    unzip -p data/aachen_net/district_map.zip StatistischeBezirkeAachen.shx > data/aachen_net/aachen_district_map.shx
    unzip -p data/aachen_net/district_map.zip StatistischeBezirkeAachen.dbf > data/aachen_net/aachen_district_map.dbf
    unzip -p data/aachen_net/district_map.zip StatistischeBezirkeAachen.prj > data/aachen_net/aachen_district_map.prj

    # gather NRW roads
    unzip -p data/aachen_net/NRW_map.zip gis_osm_roads_free_1.shp > data/aachen_net/NRW_roads.shp
    unzip -p data/aachen_net/NRW_map.zip gis_osm_roads_free_1.shx > data/aachen_net/NRW_roads.shx
    unzip -p data/aachen_net/NRW_map.zip gis_osm_roads_free_1.dbf > data/aachen_net/NRW_roads.dbf

    # gather NRW buildings
    unzip -p data/aachen_net/NRW_map.zip gis_osm_buildings_a_free_1.shp > data/aachen_net/NRW_buildings.shp
    unzip -p data/aachen_net/NRW_map.zip gis_osm_buildings_a_free_1.shx > data/aachen_net/NRW_buildings.shx
    unzip -p data/aachen_net/NRW_map.zip gis_osm_buildings_a_free_1.dbf > data/aachen_net/NRW_buildings.dbf
  #+END_SRC

* Create city map
  Put all relevant NRW data inside a ~postgresql~ database with ~postgis~ extension installed.
  Database is run localy as normal user inside a proper socket directory.

  See [[https://simonb83.github.io/making-a-map-in-matplotlib.html][here]] for details on moving ~shp~ to ~postgresql~.

  #+NAME: socket_dir
  - data/aachen_net/postgres/socket_dir/

  #+BEGIN_SRC bash :results none :tangle scripts/aachen_net/02_postgres_init.sh :var socket_dir=socket_dir
    # create and start local postgres session
    mkdir -p data/aachen_net/postgres/
    initdb -D data/aachen_net/postgres/

    mkdir -p $(pwd)/$socket_dir
    postgres -D data/aachen_net/postgres/ -k $(pwd)/$socket_dir &

    dropdb nrw -h $(pwd)/$socket_dir
    createdb nrw -h $(pwd)/$socket_dir
    psql nrw -c 'CREATE EXTENSION postgis' -h $(pwd)/$socket_dir

    echo "WARNING: this takes some time..."

    shp2pgsql -s 4326 data/aachen_net/NRW_roads.shp roads | psql nrw -h $(pwd)/$socket_dir > /dev/null
    shp2pgsql -s 4326 data/aachen_net/NRW_buildings.shp buildings | psql nrw -h $(pwd)/$socket_dir > /dev/null
  #+END_SRC

** Retrieve city border
   Extract the union of Aachen metropolitan area, in order to filter roads properly.

   #+BEGIN_SRC python :results none :noweb yes :tangle scripts/aachen_net/03_city_border.py
     <<imports_&_defaults>>
     <<projection>>
     <<districts>>

      with open('data/aachen_net/aachen_border.txt', 'w') as outfile:
          # extract border
          aachen_area = cascaded_union(district_map['geometry'])

          # convert back to (lat, long) for this purpose
          aachen_area = Polygon([projection(*coord[0:2], inverse=True) \
                                 for coord in aachen_area.exterior.coords])

          # convert border from 3D to 2D
          outfile.write(aachen_area.to_wkt())
   #+END_SRC

** Extract city information
   Create output ~shp~ for roads and buildings using the following queries.

   #+NAME: roads_query
   #+BEGIN_SRC sql
     SELECT osm_id, geom FROM roads
      WHERE fclass NOT IN ('trunk_link', 'bridleway', 'motorway',
                           'motorway_link', 'path', 'primary_link',
                           'secondary_link', 'service', 'steps',
                           'tertiary_link', 'track', 'track_grade2',
                           'track_grade3', 'track_grade4', 'track_grade5',
                           'unclassified', 'unknown')
        AND ST_Intersects(geom, ST_SetSRID(ST_GeomFromText('$aachen_border'), 4326));
   #+END_SRC

   #+NAME: buildings_query
   #+BEGIN_SRC sql
     SELECT osm_id, geom, type FROM buildings
      WHERE ST_Intersects(geom, ST_SetSRID(ST_GeomFromText('$aachen_border'), 4326));
   #+END_SRC

   #+BEGIN_SRC bash :noweb yes :results output :tangle scripts/aachen_net/04_extraction.sh :var socket_dir=socket_dir
     # extract roads around aachen border
     read aachen_border < data/aachen_net/aachen_border.txt

     # due to noweb shortcomings, first newline and leading whitespaces have to be removed
     query="
            <<roads_query>>"
     pgsql2shp -f data/aachen_net/aachen_roads -h $(pwd)/$socket_dir nrw \
               "$(echo ${query:1:${#query}} | sed 's/^[\t ]*//g')"

     query="
            <<buildings_query>>"
     pgsql2shp -f data/aachen_net/aachen_buildings -h $(pwd)/$socket_dir nrw \
               "$(echo ${query:1:${#query}} | sed 's/^[\t ]*//g')"
   #+END_SRC

** Plot the map
   Create final plot, with roads as well as population density.

   #+BEGIN_SRC python :results none :noweb yes :tangle scripts/aachen_net/05_plot_map.py :var valid_types=utils.org:valid_types
     <<all_datasets>>

     fig = plt.figure(figsize=(6, 6), frameon=False)
     ax = fig.gca()

     ax.set_title("Population density in Aachen\n",
                  fontsize=15,
                  fontweight=font_spec['font.weight'])

     district_map.plot(column='density',
                       cmap='viridis',
                       legend=True,
                       linewidth=0, # remove districts borders
                       alpha=0.7,
                       ax=ax)

     roads_map.plot(color='black',
                    alpha=0.6,
                    linewidth=0.15,
                    ax=ax)

     buildings_map.plot(color='black',
                        alpha=0.5,
                        linewidth=0.15,
                        ax=ax)

     # set title of colorbar (dirty trick)
     fig.get_axes()[1].set_title('    people/kmÂ²',
                                 fontweight=font_spec['font.weight'])

     plt.axis('off')
     plt.tight_layout(rect=[-1.25, -0.04, 1.2, 1])

     # plt.show()

     plt.savefig('figures/aachen_citymap.pdf')
     plt.close('all')
   #+END_SRC

* Create graph from city roads
** Create an abstract graph from the roads
   When creating the graph, remember ~OSM_ID~, in order to assign each building a proper edge.

   #+NAME: graph_path
   - data/aachen_net/aachen_graph.json

   #+BEGIN_SRC python :noweb yes :var valid_types=utils.org:valid_types :var graph_path=graph_path :tangle scripts/aachen_net/06_get_roads_graph.py
     <<imports_&_defaults>>
     <<projection>>
     <<roads>>
     <<buildings>>

     sg = ShapeGraph(shapefile=roads_path, to_graph=True, properties=['OSM_ID'])

     # convert graph to json
     G = json_graph.node_link_data(sg.graph)

     for node in G['nodes']:
         node['lat'], node['lon'] = sg.node_xy[node['id']]

     # use of private variable seems to be mandatory here
     edge_osm_id_map = {
         edge: sg.line_info(info.line_index).props['OSM_ID']
         for edge, info in sg._edges.items() if info.line_index is not None
     }

     for edge in G['edges']:
         if edge in edge_osm_id_map:
             G[edge[0]][edge[1]]['OSM_ID'] = edge_osm_id_map[edge]

     with open(org_flatten(graph_path), 'w') as output:
         output.write(json.dumps(G))
   #+END_SRC

** Match each building with the closest road
   Find the closest road on the map for each house, in order to set the house as a node on the road graph.
   This has to consider only roads in the major component of the city, not the unconnected ones.

   #+NAME: closest_edges_path
   - data/aachen_net/closest_edges.csv

   #+BEGIN_SRC python :noweb yes :tangle scripts/aachen_net/07_get_closest_roads.py :var valid_types=utils.org:valid_types :var closest_edges_path=closest_edges_path :var graph_path=graph_path
     <<all_datasets>>

     # load graph
     with open(org_flatten(graph_path)) as f:
         js_graph = json.load(f)

     G = json_graph.node_link_graph(js_graph)

     # precompute {edge: map_line, ...} association
     lines = {
         (x, y): LineString([ projection(G.node[x]['lon'], G.node[x]['lat']),
                              projection(G.node[y]['lon'], G.node[y]['lat']) ])
         for x, y in G.edges()
     }

     # convert to dataframe, for convenience
     lines = gpd.GeoDataFrame.from_dict(lines, orient='index')
     lines.columns = ['geometry']
     lines.index.name = 'edge'

     # compute minimum distance between each building and the roads
     def nearest_line(building, lines_):
         # get closest edge
         edge = lines_.geometry.distance(building.geometry).idxmin()
         line = lines_.loc[[edge]].geometry.values[0]

         district_index = -1
         for index, district_row in district_map.iterrows():
             if building.geometry.centroid.within(district_row.geometry):
                 district_index = index

         # avoid adding buildings which center is outside the city
         if district_index == -1:
             return

         # print(building.geometry.to_wkt())
         _, proj_point = nearest_points(building.geometry, line)

         return pd.Series({
             'osm_id': building.OSM_ID,
             'edge0': edge[0],
             'edge1': edge[1],
             'line': line,
             # location of new node
             'new_point': proj_point,
             # weight of new node
             'area': building.geometry.area,
             'district_index': district_index
         })

     # filter them
     closest_lines = buildings_map.apply(
         lambda row: nearest_line(row, lines),
         axis=1
     )

     # split evenly the population across all district buildings
     def split_population(group):
         total_area = group.area.sum()

         # collect number of people per building
         pops = []
         for _, row in group.iterrows():
             district_id = row.district_index
             district_pop = district_map.loc[district_id].population

             # make proportion
             pops.append(row.area / total_area * district_pop)

         group['population'] = pops
         del group['area']
         del group['district_index']

         return group

     # assigned each building an estimation of its number of inhabitants
     closest_lines                  \
         .groupby('district_index') \
         .apply(split_population)   \
         .to_csv(org_flatten(closest_edges_path),
                 quoting=csv.QUOTE_NONNUMERIC,
                 index=None)
   #+END_SRC

** Project each building on its road
   The graph is filled with buildings, replacing each edge
   with two edges, with the building node in the middle.

   Use projected point of the building on the road point as actual position:
   line is supposed to be payed by the customer from the road to the home,
   so there is no cost for the operator.

   #+BEGIN_SRC python :noweb yes :var valid_types=utils.org:valid_types :var graph_path=graph_path :tangle scripts/aachen_net/08_add_buildings_to_graph.py :var closest_edges_path=closest_edges_path
     <<all_datasets>>

     # read graph G
     with open(org_flatten(graph_path)) as f:
         js_graph = json.load(f)

     G = json_graph.node_link_graph(js_graph)

     closest_lines = pd.read_csv(org_flatten(closest_edges_path))

     # add new nodes, corresponding to buildings

     current_number = 0
     for _, group in closest_lines.groupby(['edge0', 'edge1']):
         edge = group['edge0'].iloc[0], group['edge1'].iloc[0]

         line = wkt.loads(group.line.iloc[0])

         # collect new point information
         new_points = []
         for _, row in group.iterrows():
             print("Added building {}/{}".format(current_number, len(closest_lines)), end="\r")
             current_number += 1

             proj_new_point = wkt.loads(row.new_point)
             new_point = Point(projection(proj_new_point.x,
                                          proj_new_point.y,
                                          inverse=True))
             new_points.append({
                 'n':          row.osm_id,
                 'new_point':  new_point,
                 'population': row.population,
                 'proj':       line.project(new_point)
             })

         # sort them via projection
         new_points.sort(key=lambda x: x['proj'])

         # add all new nodes to graph
         for new_point in new_points:
             G.add_node(node_for_adding=new_point['n'],
                        lon=new_point['new_point'].x,
                        lat=new_point['new_point'].y,
                        population=new_point['population'])

         # remove old edge
         G.remove_edge(*edge)

         # add new ones
         G.add_edge(edge[0], new_points[0]['n'])

         # loop over couples of subsequent points
         for point1, point2 in zip(new_points[:-1], new_points[1:]):
             # distance will be added later (also for untouched edges)
             G.add_edge(point1['n'], point2['n'])

         G.add_edge(new_points[-1]['n'], edge[1])

     # polish the graph

     # relevant information for nodes are
     # - lat
     # - lon
     # - population (> 0 if building)
     for node_id in G.nodes:
         node = G.nodes[node_id]

         lat = node['lat']
         lon = node['lon']

         if 'population' not in node:
             population = 0
         else:
             population = node['population']

         node.clear()
         node['lat'] = lat
         node['lon'] = lon
         node['population'] = population

     # prune unuseful nodes (no buildings, just two neighbours)
     for node in G.nodes(data=True):
         if G.degree(node[0]) == 2 and node[1]['population'] == 0:
             neighbours_ids = [id_ for id_ in G[node[0]]]

             # remove previous two edges
             G.remove_edge(node[0], neighbours_ids[0])
             G.remove_edge(node[0], neighbours_ids[1])

             G.add_edge(neighbours_ids[0], neighbours_ids[1])

     # relevant information for edges is only their length
     def Haversine_distance(point0, point1):
         lon1, lat1 = point0
         lon2, lat2 = point1

         # use precise measure for distance
         radius = 6371  # km

         # compute distance using Haversine formula
         dlat = math.radians(lat2 - lat1)
         dlon = math.radians(lon2 - lon1)
         a = (math.sin(dlat / 2) * math.sin(dlat / 2) +
              math.cos(math.radians(lat1)) * math.cos(math.radians(lat2)) *
              math.sin(dlon / 2) * math.sin(dlon / 2))
         c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
         d = radius * c

         # use distance in meters
         return d * 1000

     for edge in G.edges:
         # read (and compute distance) between begin and end point
         node0 = G.nodes[edge[0]]
         node1 = G.nodes[edge[1]]

         edge_info = G.edges[edge]
         edge_info.clear()

         point0 = node0['lon'], node0['lat']
         point1 = node1['lon'], node1['lat']

         edge_info['distance'] = Haversine_distance(point0, point1)

     # certains id seems to be of type numpy.int64 in edges definition!
     # better fix them
     for edge_data in G.edges(data=True):
         if type(edge_data[0]) == np.int64 or \
            type(edge_data[1]) == np.int64:
             G.remove_edge(edge_data[0], edge_data[1])
             G.add_edge(int(edge_data[0]), int(edge_data[1]), **edge_data[2])

     with open(org_flatten(graph_path).replace('.json', '_complete.json'), 'w') as output:
         output.write(json.dumps(G))
   #+END_SRC

** Plot obtained graph on the map
   Plot final graph on top of district map.

   #+BEGIN_SRC python :noweb yes :var valid_types=utils.org:valid_types :var graph_path=graph_path :tangle scripts/aachen_net/09_plot_city_graph.py
     <<imports_&_defaults>>
     <<projection>>
     <<districts>>

     # read graph G
     with open(org_flatten(graph_path).replace('.json', '_complete.json')) as f:
         js_graph = json.load(f)

     G = json_graph.node_link_graph(js_graph)

     ## "convert" graph to GeoDataFrame

     # collect data into proper lists
     nodes = G.nodes(data=True)

     nodes_info = []
     for id_, data in nodes:
         point = Point(data['lon'], data['lat'])
         nodes_info.append({'geometry': point, **data})

     edges_info = []
     for node_id1, node_id2, data in G.edges(data=True):
         edge = LineString((
             (nodes[node_id1]['lon'], nodes[node_id1]['lat']),
             (nodes[node_id2]['lon'], nodes[node_id2]['lat'])
         ))

         edges_info.append({'geometry': edge, **data})

     ## provide GeoDataFrames
     nodes_df = gpd.GeoDataFrame(nodes_info)
     nodes_df.crs = {'init' :'epsg:4326'} # long-lat projection
     nodes_df = nodes_df.to_crs(projection.srs)

     edges_df = gpd.GeoDataFrame(edges_info)
     edges_df.crs = {'init' :'epsg:4326'} # long-lat projection
     edges_df = edges_df.to_crs(projection.srs)

     ## plot everything

     fig = plt.figure(figsize=(6, 6), frameon=False)
     ax = fig.gca()

     ax.set_title("Detail of extracted city graph\n",
                  fontsize=15,
                  fontweight=font_spec['font.weight'])

     # plot just city external border
     aachen_border = cascaded_union(district_map.geometry)
     gpd.GeoDataFrame({'geometry': [aachen_border]}).plot(color='white',
                                                          edgecolor='black',
                                                          linewidth=0.5,
                                                          ax=ax)

     nodes_df.plot(ax=ax,
                   markersize=1,
                   color='black',
                   zorder=2)

     edges_df.plot(ax=ax,
                   color='grey',
                   linewidth=0.5,
                   zorder=1)

     plt.axis('off')

     # cut a window for better visualization
     ax.set_xlim(292461, 298772)
     ax.set_ylim(5625000, 5630000)
     plt.tight_layout(rect=[-0.1, 0, 1, 1])

     # plt.show()

     plt.savefig('figures/aachen_city_graph.png')
     plt.close('all')
   #+END_SRC

* Solve associated ILP problem
  #+BEGIN_SRC python :noweb yes :var graph_path=graph_path :tangle scripts/aachen_net/10_ILP.py
    <<imports_&_defaults>>

    import cplex
    from docplex.mp.model import Model

    G = nx.read_gml(org_flatten(graph_path).replace('.json', '_complete.gml')).to_directed()

    # add fake root node to G, with a zero-length arc for all the nodes
    G.add_node('r', population=0)

    for node_id in G.nodes:
        G.add_edge('r', node_id, distance=0)

    ####################
    # Model parameters #
    ####################
    d_M = 100 # meters
    n_M = 50  # users per DSLAM

    n_DSLAM_max = 1500
    n_DSLAM_min = 1000

    n_T = sum([data['population'] > 0 for _, data in G.nodes(data=True)])
    ####################

    m = Model(name='dslam')

    X = {}
    for source, target in G.edges:
        if source not in X:
            X[source] = {}

        ## active edge indicator
        var_name = "x_{}->{}".format(source, target)
        X[source][target] = m.binary_var(name=var_name)

    D = {}
    for node_id, data in G.nodes(data=True):
        ## set distance counter
        d = m.continuous_var(name="d_{}".format(node_id))
        D[node_id] = d

        ## domain conditions for distance
        m.add_constraint(d >= 0)
        m.add_constraint(d <= d_M)

        ## active ingoing edges for each node
        in_count = 0
        for source, target in G.in_edges(node_id):
            assert target == node_id

            in_count += X[source][node_id]

        ## tree conditions
        if node_id == 'r':
            m.add_constraint(in_count = 0)
        elif data['population'] > 0:
            # terminal nodes reachability
            m.add_constraint(in_count = 1)
        else:
            m.add_constraint(in_count <= 1)

        ## zero distance for inactive nodes
        m.add_constraint(d <= d_M * in_count)

    ## limit number of DSLAMs using artificial root node r
    out_root_count = 0
    for source, target in G.outedges('r'):
        assert target == 'r'

        out_root_count += X[source]['r']

    m.add_constraint(out_root_count <= n_DSLAM_max)
    m.add_constraint(out_root_count >= n_DSLAM_min)

    ## distance increment
    for source, target, data in G.edges(data=True):
        m.add_constraint(
            d[target] - d[source] <= edge_length + (d_M - edge_length) * (1 - X[source][target])
        )

        m.add_constraint(
            d[target] - d[source] >= edge_length - (d_M + edge_length) * (1 - X[source][target])
        )

    ## number of leaves in each subtree
    N = {}
    for node_id, data in G.nodes(data=True):
        # ignore root, only subtrees matter
        if node_id == 'r':
            continue

        n = m.integer_var(name="n_{}".format(node_id))
        N[node_id] = n

        m.add_constraint(n >= 0)
        m.add_constraint(n <= n_M)

    N_prime = {}
    for source, target in G.edges:
        # ignore root, only subtrees matter
        if source == 'r':
            continue

        if source not in N_prime:
            N_prime[source] = {}

        var_name = "n_prime_{}->{}".format(source, target)
        N_prime[source][target] = m.integer_var(name=var_name)

        # domain
        m.add_constraint(N_prime[source][target] >= 0)
        m.add_constraint(N_prime[source][target] <= N[target])

        # relationship with n_j
        m.add_constraint(
            N_prime[source][target] <= X[source][target] * n_T
        )
        m.add_constraint(
            N_prime[source][target] >= N[target] - (1 - X[source][target]) * n_T
        )

    ## propagate information on n for all non-terminal nodes
    for node_id, data in G.nodes(data=True):
        # ignore root, only subtrees matter
        if node_id == 'r':
            continue

        if data['population'] > 0:
            # TODO n should be proportional to population itself
            # for terminal nodes
            m.add_constraint(N[node_id] == 1)
        else:
            out_count = 0
            for source, target in G.outedges(node_id):
                assert target == node_id

                out_count += X[source][target]

            m.add_constraint(N[node_id] == out_count)



    for index, (source, target, data) in enumerate( G.edges(data=True) ):
        pass
  #+END_SRC
* COMMENT Local variables
  # Local Variables:
  # eval: (add-hook 'before-save-hook (lambda () (indent-region (point-min) (point-max) nil)) t t)
  # eval: (add-hook 'org-babel-pre-tangle-hook (lambda () (org-babel-lob-ingest "utils.org")) t t)
  # End:
