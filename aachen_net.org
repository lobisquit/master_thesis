#+PROPERTY: header-args :mkdirp yes
#+PROPERTY: header-args:python :shebang "#!/usr/bin/python \n# -*- coding: utf-8 -*-\nfrom __future__ import print_function"
#+STARTUP: indent

* Retrieve datasets
Download all needed files from Aachen city repository.

These are under a special license: "Data license Germany - Attribution - Version 2.0".
#+NAME: population_density_link
http://offenedaten.aachen.de/dataset/81650028-ef21-4f1b-a991-9e3a3f01c729/resource/460bfe18-7df4-49fb-b5d0-6dfc1d0cffd5/download/20170630opendataaachen-daten-statistische-bezirkealle.csv

#+NAME: district_map_link
http://offenedaten.aachen.de/dataset/5ea893af-8f1d-4658-9066-8f05daed1022/resource/6dfc1b81-26d9-4ed8-b8c4-a61013659f51/download/statistischebezirkeaachen.zip

#+NAME: NRW_map_link
http://download.geofabrik.de/europe/germany/nordrhein-westfalen-latest-free.shp.zip

For the roads details, see [[https://simonb83.github.io/making-a-map-in-matplotlib.html][here]].

#+BEGIN_SRC bash :var population_density=population_density_link district_map=district_map_link NRW_map=NRW_map_link :results none :tangle scripts/aachen_net/01_download.sh
  mkdir -p data/aachen_net/

  # download
  wget -c $population_density -O data/aachen_net/20170630_population_density_temp.csv
  wget -c $district_map -O data/aachen_net/district_map.zip
  wget -c $NRW_map -O data/aachen_net/NRW_map.zip

  # preprocess
  awk -F, '{print $1 "," $3}' data/aachen_net/20170630_population_density_temp.csv > data/aachen_net/20170630_population_density.csv
  rm -f data/aachen_net/20170630_population_density_temp.csv

  # gather city district borders
  unzip -p data/aachen_net/district_map.zip StatistischeBezirkeAachen.shp > data/aachen_net/aachen_district_map.shp
  unzip -p data/aachen_net/district_map.zip StatistischeBezirkeAachen.shx > data/aachen_net/aachen_district_map.shx
  unzip -p data/aachen_net/district_map.zip StatistischeBezirkeAachen.dbf > data/aachen_net/aachen_district_map.dbf
  unzip -p data/aachen_net/district_map.zip StatistischeBezirkeAachen.prj > data/aachen_net/aachen_district_map.prj

  # gather NRW roads
  unzip -p data/aachen_net/NRW_map.zip gis_osm_roads_free_1.shp > data/aachen_net/NRW_roads.shp
  unzip -p data/aachen_net/NRW_map.zip gis_osm_roads_free_1.shx > data/aachen_net/NRW_roads.shx
  unzip -p data/aachen_net/NRW_map.zip gis_osm_roads_free_1.dbf > data/aachen_net/NRW_roads.dbf

  # gather NRW buildings
  unzip -p data/aachen_net/NRW_map.zip gis_osm_buildings_a_free_1.shp > data/aachen_net/NRW_buildings.shp
  unzip -p data/aachen_net/NRW_map.zip gis_osm_buildings_a_free_1.shx > data/aachen_net/NRW_buildings.shx
  unzip -p data/aachen_net/NRW_map.zip gis_osm_buildings_a_free_1.dbf > data/aachen_net/NRW_buildings.dbf
#+END_SRC

* Create city map
Put all relevant NRW data inside a ~postgresql~ database with ~postgis~ extension installed.
Database is run localy as normal user inside a proper socket directory.

See [[https://simonb83.github.io/making-a-map-in-matplotlib.html][here]] for details on moving ~shp~ to ~postgresql~.

#+NAME: socket_dir
- data/aachen_net/postgres/socket_dir/

#+BEGIN_SRC bash :results none :tangle scripts/aachen_net/02_postgres_init.sh :var socket_dir=socket_dir
  # create and start local postgres session
  mkdir -p data/aachen_net/postgres/
  initdb -D data/aachen_net/postgres/

  mkdir -p $(pwd)/$socket_dir
  postgres -D data/aachen_net/postgres/ -k $(pwd)/$socket_dir &

  dropdb nrw -h $(pwd)/$socket_dir
  createdb nrw -h $(pwd)/$socket_dir
  psql nrw -c 'CREATE EXTENSION postgis' -h $(pwd)/$socket_dir

  echo "WARNING: this takes some time..."

  shp2pgsql -s 4326 data/aachen_net/NRW_roads.shp roads | psql nrw -h $(pwd)/$socket_dir > /dev/null
  shp2pgsql -s 4326 data/aachen_net/NRW_buildings.shp buildings | psql nrw -h $(pwd)/$socket_dir > /dev/null
#+END_SRC

** Retrieve city border
Extract the union of Aachen metropolitan area, in order to filter roads properly.

#+BEGIN_SRC python :results none :noweb yes :tangle scripts/aachen_net/03_city_border.py
  <<imports_&_defaults>>
  <<projection>>
  <<districts>>

   with open('data/aachen_net/aachen_border.txt', 'w') as outfile:
       # extract border
       aachen_area = cascaded_union(district_map['geometry'])

       # convert back to (lat, long) for this purpose
       aachen_area = Polygon([projection(*coord[0:2], inverse=True) \
                              for coord in aachen_area.exterior.coords])

       # convert border from 3D to 2D
       outfile.write(aachen_area.to_wkt())
#+END_SRC

** Extract city information
Create output ~shp~ for roads and buildings using the following queries.

#+NAME: roads_query
#+BEGIN_SRC sql
  SELECT osm_id, geom FROM roads
   WHERE fclass NOT IN ('trunk_link', 'bridleway', 'motorway',
                        'motorway_link', 'path', 'primary_link',
                        'secondary_link', 'service', 'steps',
                        'tertiary_link', 'track', 'track_grade2',
                        'track_grade3', 'track_grade4', 'track_grade5',
                        'unclassified', 'unknown')
     AND ST_Intersects(geom, ST_SetSRID(ST_GeomFromText('$aachen_border'), 4326));
#+END_SRC

#+NAME: buildings_query
#+BEGIN_SRC sql
  SELECT osm_id, geom, type FROM buildings
   WHERE ST_Intersects(geom, ST_SetSRID(ST_GeomFromText('$aachen_border'), 4326));
#+END_SRC

#+BEGIN_SRC bash :noweb yes :results output :tangle scripts/aachen_net/04_extraction.sh :var socket_dir=socket_dir
  # extract roads around aachen border
  read aachen_border < data/aachen_net/aachen_border.txt

  # due to noweb shortcomings, first newline and leading whitespaces have to be removed
  query="
         <<roads_query>>"
  pgsql2shp -f data/aachen_net/aachen_roads -h $(pwd)/$socket_dir nrw \
            "$(echo ${query:1:${#query}} | sed 's/^[\t ]*//g')"

  query="
         <<buildings_query>>"
  pgsql2shp -f data/aachen_net/aachen_buildings -h $(pwd)/$socket_dir nrw \
            "$(echo ${query:1:${#query}} | sed 's/^[\t ]*//g')"
#+END_SRC

** Plot the map
Create final plot, with roads as well as population density.

#+BEGIN_SRC python :results none :noweb yes :tangle scripts/aachen_net/05_plot_map.py :var valid_types=flatten(utils.org:valid_types)
  <<all_datasets>>

  fig = plt.figure(figsize=(6, 6), frameon=False)
  ax = fig.gca()

  district_map.plot(column='density',
                    cmap='viridis',
                    legend=True,
                    linewidth=0, # remove districts borders
                    alpha=0.7,
                    ax=ax)

  roads_map.plot(color='black',
                 alpha=0.6,
                 linewidth=0.15,
                 ax=ax)

  buildings_map.plot(color='black',
                     alpha=0.5,
                     linewidth=0.15,
                     ax=ax)

  # set title of colorbar (dirty trick)
  fig.get_axes()[1].set_title('    people/km²',
                              fontweight=font_spec['font.weight'],
                              fontsize=12)

  fig.get_axes()[1].tick_params(labelsize=10)

  plt.axis('off')
  plt.tight_layout(rect=[-1.25, -0.04, 1.2, 1])

  # plt.show()

  plt.savefig('figures/aachen_citymap.png', dpi=250)
  plt.close('all')
#+END_SRC

* Create graph from city roads
** Create an abstract graph from the roads
When creating the graph, remember ~OSM_ID~, in order to assign each building a proper edge.

#+NAME: graph_path
- data/aachen_net/aachen_graph

#+BEGIN_SRC python :noweb yes :var valid_types=flatten(utils.org:valid_types) :var graph_path=flatten(graph_path) :tangle scripts/aachen_net/06_get_roads_graph.py
  <<imports_&_defaults>>
  <<projection>>
  <<roads>>
  <<buildings>>

  sg = ShapeGraph(shapefile=roads_path, to_graph=True, properties=['OSM_ID'])

  # convert graph to json
  G = json_graph.node_link_data(sg.graph)

  for node in G['nodes']:
      node['lat'], node['lon'] = sg.node_xy[node['id']]

  # use of private variable seems to be mandatory here
  edge_osm_id_map = {
      edge: sg.line_info(info.line_index).props['OSM_ID']
      for edge, info in sg._edges.items() if info.line_index is not None
  }

  for edge in G['edges']:
      if edge in edge_osm_id_map:
          G[edge[0]][edge[1]]['OSM_ID'] = edge_osm_id_map[edge]

  with open(graph_path + "_0_raw.json", 'w') as output:
      output.write(json.dumps(G))
#+END_SRC

** Adjust road length
For our purposes, roads should have a maximum length of 200m and a minimum of
20m, in order to make our setting buildings in street corners accurate enough.

#+NAME: MIN_LENGTH
- 20

#+NAME: MAX_LENGTH
- 200

#+BEGIN_SRC python :noweb yes :tangle scripts/aachen_net/07_fix_short_roads.py :var graph_path=flatten(graph_path) :var min_length=flatten(MIN_LENGTH)
  <<imports_&_defaults>>

  # load graph
  with open(graph_path + "_0_raw.json") as f:
      js_graph = json.load(f)

  G = json_graph.node_link_graph(js_graph)

  assert nx.is_connected(G), "Raw G is not connected"

  ## remove too short roads

  MIN_LENGTH = int(min_length)

  def order_edge(edge):
      return min(edge), max(edge)

  # precompute expensive distance dictionary (update each cycle)
  edge_length_map = { order_edge(edge): node_distance(G, *edge)
                      for edge in G.edges() }

  # proceed splitting all roads that are shorter than MIN_LENGTH
  while True:
      current_min_length = float('inf')
      min_source = None
      min_target = None

      n = 0
      # compute length of each road
      for edge, length in edge_length_map.items():
          # keep track of the shortest road
          if length < current_min_length:
              current_min_length = length
              min_source, min_target = edge

          # count how many are still there
          if length < MIN_LENGTH:
              n += 1

      if current_min_length > MIN_LENGTH:
          break

      # segment from min_source to min_target
      min_g = Geodesic.WGS84.Inverse(
          G.node[min_source]['lat'], G.node[min_source]['lon'],
          G.node[min_target]['lat'], G.node[min_target]['lon']
      )

      # use mid-point for contracted node position
      mid_point = Geodesic.WGS84.Direct(lat1= G.node[min_source]['lat'],
                                        lon1= G.node[min_source]['lon'],
                                        azi1= min_g['azi1'],
                                        s12=  min_g['s12']/2)

      # new edges from min_target will be from min_source
      # work on (min_target, ...) but avoid (min_target, min_source)
      new_edges = [ (min_source, w)
                    for x, w in G.edges(min_target)
                    if w != min_source ]

      # remove edges touching min_target from the lengths dictionary
      for edge in G.edges(min_target):
          del edge_length_map[ order_edge(edge) ]

      # remove node and its edges and add new ones
      G.remove_node(min_target)
      G.add_edges_from(new_edges)

      # move node to keep in the middle point
      G.node[min_source].clear()
      G.node[min_source]['lat'] = mid_point['lat2']
      G.node[min_source]['lon'] = mid_point['lon2']

      # min_source has moved: recompute distances for each edge
      for edge in G.edges(min_source):
          edge_length_map[ order_edge(edge) ] = node_distance(G, *edge)

      # compute distances for each of the new edges
      for edge in new_edges:
          edge_length_map[ order_edge(edge) ] = node_distance(G, *edge)

      print('{} remaining'.format(n - 1), end="\r")

  # check if operation was successful
  refresh_distances(G)
  assert min(data['length'] for _, _, data in G.edges(data=True)) >= MIN_LENGTH

  assert nx.is_connected(G), "Intermediate G is not connected"

  with open(graph_path + "_1_temp.json", 'w') as output:
      output.write(json.dumps(json_graph.node_link_data(G)))
#+END_SRC

Use saved data (with roads /long/ enough) to start working on the ones too long.

#+BEGIN_SRC python :noweb yes :tangle scripts/aachen_net/08_fix_long_roads.py :var graph_path=flatten(graph_path) :var min_length=flatten(MIN_LENGTH) :var max_length=flatten(MAX_LENGTH)
  <<imports_&_defaults>>

  # load graph
  with open(graph_path + "_1_temp.json", "r") as f:
      js_graph = json.load(f)

  G = json_graph.node_link_graph(js_graph)

  assert nx.is_connected(G), "Raw G is not connected!"

  ## split roads that are too long

  MIN_LENGTH = int(min_length)
  MAX_LENGTH = int(max_length)

  # collect edges (not to mess up with G iterator)
  edges_to_split_distance = { edge: node_distance(G, *edge)
                              for edge in G.edges()
                              if node_distance(G, *edge) >= MAX_LENGTH }

  progress = 1
  for (source, target), distance in edges_to_split_distance.items():
      print("{}/{} roads splitted".format(progress, len(edges_to_split_distance)), end='\r')
      progress += 1

      G.remove_edge(source, target)

      # number of new segments
      n_segments = int(ceil(distance / MAX_LENGTH))

      # n + source + target now are in the segment
      delta = distance / n_segments

      if delta > MAX_LENGTH:
          print("Nope", delta)
          exit(1)

      # run along segment from source to target
      g = Geodesic.WGS84.Inverse(
          G.node[source]['lat'], G.node[source]['lon'],
          G.node[target]['lat'], G.node[target]['lon']
      )

      new_points = []
      for i in range(1, n_segments):
          # disseminate points every delta
          point = Geodesic.WGS84.Direct(lat1= G.node[source]['lat'],
                                        lon1= G.node[source]['lon'],
                                        azi1= g['azi1'],
                                        s12=  delta * i)

          new_points.append(max(G.nodes) + 1)
          G.add_node(max(G.nodes) + 1,
                     lat=point['lat2'],
                     lon=point['lon2'])

      G.add_edge(source, new_points[0])

      for j in range(n_segments - 2):
          G.add_edge(new_points[j], new_points[j+1])

      G.add_edge(new_points[-1], target)

  # check distances respect the constraints
  refresh_distances(G)
  assert max(data['length'] for _, _, data in G.edges(data=True)) <= MAX_LENGTH, "Max length exceeded"
  assert min(data['length'] for _, _, data in G.edges(data=True)) >= MIN_LENGTH, "Min length not respected"

  assert nx.is_connected(G), "Processed G not connected!"

  with open(graph_path + "_1_fix_roads.json", 'w') as output:
      output.write(json.dumps(json_graph.node_link_data(G)))
#+END_SRC

Find the closest road on the map for each house, in order to set the house as a node on the road graph.
This has to consider only roads in the major component of the city, not the unconnected ones.

** Assign buildings to nodes
#+NAME: closest_nodes_path
- data/aachen_net/closest_nodes.csv

Load data from buildings dataset into graph.

#+BEGIN_SRC python :noweb yes :tangle scripts/aachen_net/09_add_buildings.py :var valid_types=flatten(utils.org:valid_types) :var closest_nodes_path=flatten(closest_nodes_path) :var graph_path=flatten(graph_path)
  <<all_datasets>>

  # load graph
  with open(graph_path + "_1_fix_roads.json") as f:
      js_graph = json.load(f)

  G = json_graph.node_link_graph(js_graph)

  assert nx.is_connected(G), "Fixed roads G is not connected"

  ## filter out buildings, heuristically

  # remove buildings that are too big or too small to be residential
  buildings_map = buildings_map[ (buildings_map.area > 40) &
                                 (buildings_map.area < 2000) ]

  ## assign each building area and district to a node

  # pre-compute all (projected) node points with scipy.spatial.KDTree
  node_ids = list(G.nodes)
  node_coords = list(projection(data['lon'], data['lat'])
                     for _, data in G.nodes(data=True))
  search_tree = spatial.KDTree(node_coords)

  building_distances = []

  building_index = 0
  for _, building in buildings_map.iterrows():
      if building_index % 200 == 0:
          print("{}/{}".format(building_index, len(buildings_map)), end='\r')
      building_index += 1

      ## work only if building can be assigned to a district (not ones outside
      ## city)

      district_index = -1
      for index, district_row in district_map.iterrows():
          if building.geometry.centroid.within(district_row.geometry):
              district_index = index

      # avoid adding buildings which center is outside the city
      if district_index == -1:
          continue

      ## find closest point in the graph

      _, min_node_index = search_tree.query( (building.geometry.centroid.x,
                                              building.geometry.centroid.y) )
      node_id = node_ids[min_node_index]

      # measure building -> node distance precisely
      building_lon, building_lat = projection(building.geometry.centroid.x,
                                              building.geometry.centroid.y,
                                              inverse=True)

      node_lon, node_lat = projection(*node_coords[min_node_index], inverse=True)

      min_dist = compute_distance({'lon': building_lon, 'lat': building_lat},
                                  {'lon': node_lon,     'lat': node_lat    })

      ## register value both in error measurer and graph

      building_distances.append(min_dist)

      node_data = G.node[node_id]

      # fill the structures if needed
      if 'district_count' not in node_data:
          node_data['district_count'] = {}

      if district_index not in node_data['district_count']:
          node_data['district_count'][district_index] = 0

      # update values for the node: each building contributes with its area to
      # the district count, in order to have

      # 1) total building area assigned to the node
      # 2) voting on district (based on area) to assigned the node to a district
      node_data['district_count'][district_index] += building.geometry.area

  with open('data/aachen_net/buildings_position_error.csv', 'w') as f:
      for dist in building_distances:
          f.write("{}\n".format(dist))

  with open(graph_path + "_2_temp.json", 'w') as output:
      output.write(json.dumps(json_graph.node_link_data(G)))
#+END_SRC

Based on area and district metric, assign each node a number of internet customer lines.

#+BEGIN_SRC python :noweb yes :tangle scripts/aachen_net/10_compute_n_lines.py :var closest_nodes_path=flatten(closest_nodes_path) :var graph_path=flatten(graph_path)
  <<imports_&_defaults>>
  <<districts>>
  <<population>>

  with open(graph_path + "_2_temp.json") as f:
      js_graph = json.load(f)

  G = json_graph.node_link_graph(js_graph)

  ## assign the district by majority vote on area

  # nodes with no area have not to be assigned any district
  for node_id in G.nodes():
      node_data = G.node[node_id]

      node_data['area'] = 0
      node_data['district'] = None

      # override values if needed
      if 'district_count' in node_data:
          area_count = node_data['district_count']

          node_data['area'] = sum(area_count.values())
          node_data['district'] = max(area_count, key=lambda x: area_count[x])

          del node_data['district_count']

  ## split population across all nodes in the same district

  # compute total building area per district
  district_area_map = { id_: 0 for id_ in district_map.index }
  for node_id, data in G.nodes(data=True):
      if data['district']:
          district_area_map[int(data['district'])] += data['area']

  # distribute population accordingly
  for node_id in G.nodes():
      node_data = G.node[node_id]

      if node_data['district']:
          district_id = int(node_data['district'])

          node_data['population'] = \
              node_data['area'] / \
              district_area_map[district_id] * \
              district_map.loc[district_id].population
      else:
          node_data['population'] = 0

      del node_data['area']
      del node_data['district']

  ## this section is /completely/ heuristic! done to match probable (supposed)
  ## numbers about Aachen network

  # compute number of lines per node, given assigned population
  for node_id in G.nodes():
      node_data = G.node[node_id]

      n_lines = int(node_data['population'] // 6)

      # avoid number of lines too small or too big
      if n_lines < 1:
          node_data['n_lines'] = 0
      elif n_lines > 48:
          node_data['n_lines'] = 48
      else:
          node_data['n_lines'] = n_lines

      del node_data['population']

  with open(graph_path + "_2_added_buildings.json", 'w') as output:
      output.write(json.dumps(json_graph.node_link_data(G)))

      # since this is the last process, just save it as "complete"
  with open(graph_path + "_complete.json", 'w') as output:
      output.write(json.dumps(json_graph.node_link_data(G)))
#+END_SRC

TODO
-[X] assign each node its corresponding n_lines, based on area, district
-[ ] cleanup unneccesary nodes: non-building leaves and degree-2 non-building nodes

** Plot obtained graph on the map
Plot final graph on top of district map.

#+BEGIN_SRC python :noweb yes :var valid_types=flatten(utils.org:valid_types) :var graph_path=flatten(graph_path) :tangle scripts/aachen_net/11_plot_city_graph.py
  <<imports_&_defaults>>
  <<projection>>
  <<districts>>

  # read graph G
  with open(graph_path + "_complete.json", 'r') as f:
      js_graph = json.load(f)

  G = json_graph.node_link_graph(js_graph)

  ## plot everything
  fig = plt.figure(figsize=(6, 6), frameon=False)
  ax = fig.gca()

  plot_graph(G,
             ax=ax,
             title="Detail of extracted city graph\n")

  # plot just city external border
  aachen_border = cascaded_union(district_map.geometry)
  gpd.GeoDataFrame({'geometry': [aachen_border]}).plot(color='white',
                                                       edgecolor='black',
                                                       linewidth=0.5,
                                                       ax=ax,
                                                       zorder=0)

  # cut a window for better visualization
  ax.set_xlim(293117, 295351)
  ax.set_ylim(5627800, 5629570)
  plt.tight_layout(rect=[-0.11, 0, 1, 1])

  # plt.show()

  plt.savefig('figures/aachen_city_graph.png', dpi=250)
  plt.close('all')
#+END_SRC

* Solve associated ILP problem

#+NAME: dummy_graph_path
- data/aachen_net/dummy_graph.json

#+NAME: number_of_nodes
- 40

#+BEGIN_SRC python :results silent :var dummy_graph_path=flatten(dummy_graph_path) :var number_of_nodes=flatten(number_of_nodes) :tangle scripts/aachen_net/12_dummy_graph_generator.py
  import json
  from math import sqrt
  import random
  import matplotlib.pyplot as plt
  import networkx as nx
  from networkx.readwrite import json_graph

  nodes = []

  G = nx.Graph()

  random.seed(13)

  N = int(number_of_nodes)

  def distance(i, j):
      delta_lat = G.node[i]['lat'] - G.node[j]['lat']
      delta_lon = G.node[i]['lon'] - G.node[j]['lon']

      return sqrt(delta_lat**2 + delta_lon**2)

  for i in range(N):
      if random.random() < 0.2:
          n_lines = 0
      else:
          n_lines = int(random.gauss(10, 3))

      G.add_node(i,
                 n_lines=n_lines,
                 lat=random.random() * sqrt(N),
                 lon=random.random() * sqrt(N))

  for i in range(N):
      for j in range(N):
          if distance(i, j) < 2:
              G.add_edge(i, j)

  # randomly connect two components at a time
  while not nx.is_connected(G):
      comps = list(nx.connected_components(G))

      for _ in range(N//10):
          comp1, comp2 = random.sample(comps, 2)
          node1 = random.choice(list(comp1))
          node2 = random.choice(list(comp2))

          G.add_edge(node1, node2)

  assert nx.is_connected(G)

  for node_id, pos in nx.spring_layout(G).items():
      G.node[node_id]['lat'] = pos[0]
      G.node[node_id]['lon'] = pos[1]

  for i, j in G.edges():
      G[i][j]['length'] = distance(i, j)

  nx.draw_kamada_kawai(G)
  plt.show()

  with open(dummy_graph_path, 'w') as output:
      output.write(json.dumps(json_graph.node_link_data(G)))
#+END_SRC

$c_r$, cost per sub-root node has to consider also the cable to reach the first level router.
We estimate 1000€ for the DSLAM and 4000€ for the mentioned connection.

See [[https://www.itscosts.its.dot.gov][here]] for pricing. TODO cite as a source

#+NAME: model_params
| $n_M$ [unit]   |   50 |
| $d_M$ [m]      | 1500 |
| $c_r$ [€/unit] | 5000 |
| $c_f$ [€/m]    |    3 |
| $c_c$ [€/m]    |    1 |
| $c_e$ [€/m]    |   50 |

#+NAME: choose_graph
- non-dummy

#+BEGIN_SRC python :noweb yes :var choose_graph=flatten(choose_graph) :var graph_path=flatten(graph_path) :var dummy_graph_path=flatten(dummy_graph_path) :var model_params=model_params :tangle scripts/aachen_net/13_ILP.py :results silent
  import csv
  import json
  import logging
  import math
  from math import sqrt
  from pathlib import Path

  import networkx as nx
  from networkx.readwrite import json_graph

  import cplex
  from docplex.mp.model import Model

  cplex_engine = cplex.Cplex()
  cplex_engine.parameters.mip.display.set(5)
  cplex_engine.parameters.mip.interval.set(-1)

  ##############################
  # Load and pre-process graph #
  ##############################
  if choose_graph == "dummy":
      path = dummy_graph_path
  else:
      path = graph_path + "_complete.json"

  with open(path) as f:
      js_graph = json.load(f)

  G = G.to_directed()
  # add artificial root node to G, with a zero-length arc for all the nodes

  G.add_node('r', n_lines=0, lat=-1, lon=0)

  for node_id in G.nodes:
      # TODO check if node is in R (candidate sub-roots)
      G.add_edge('r', node_id, length=0)

  ####################
  # Model parameters #
  ####################
  params = { param[1:4]: value
             for param, value in model_params
             if param != "Parameter" }

  ###################
  # Setup variables #
  ###################

  m = Model(log_output=True)

  def name(source, target=None, var='x'):
      if target:
          return "{}_{}~{}".format(var, source, target)
      else:
          return "{}_{}".format(var, source)

  X = {}
  N = {}
  for i, (source, target) in enumerate(G.edges):
      if i % 10000 == 0:
          print("Initializing edge {}/{}".format(i, len(G.edges)), end='\r')

      if source not in X:
          X[source] = {}

      if source not in N:
          N[source] = {}

      ## active edge indicator
      X[source][target] = m.binary_var(name=name(source, target, var='x'))
      N[source][target] = m.continuous_var(name=name(source, target, var='n'))
      m.add_constraint(ct=N[source][target] >= 0,
                       ctname="{} >= 0".format(name(source, target, var='n')))

  D = {}
  for i, (node_id, data) in enumerate(G.nodes(data=True)):
      if i % 10000 == 0:
          print("Initializing node {}/{}".format(i, len(G.nodes)), end='\r')

      ## set distance counter
      D[node_id] = m.continuous_var(name=name(node_id, var='d'))
      m.add_constraint(ct=D[node_id] >= 0,
                       ctname="{} >= 0".format(name(source, target, var='d')))

  logger.info('Initialized variables')

  ######################
  # Objective function #
  ######################

  obj_func = 0

  # A), B) ~> suppose full-fiber for now
  for node_id in G.nodes():
      obj_func += D[node_id] * params['c_f']

  # C)
  for source, target, data in G.edges(data=True):
      obj_func += X[source][target] * data['length'] * params['c_e']

  # D)
  for source, target in G.out_edges('r'):
      obj_func += X[source][target] * params['c_r']

  m.set_objective('min', obj_func)

  logger.info('Initialized objective function')

  ###############
  # Constraints #
  ###############

  for i, (node_id, data) in enumerate(G.nodes(data=True)):
      if i % 1000 == 0:
          print("Constraints on node {}/{}".format(i, len(G.nodes)), end='\r')

      in_count_X = 0
      in_count_N = 0
      for source, target in G.in_edges(node_id):
          in_count_X += X[source][target]
          in_count_N += N[source][target]

      out_count_X = 0
      out_count_N = 0
      for source, target in G.out_edges(node_id):
          out_count_X += X[source][target]
          out_count_N += N[source][target]

      # 2)
      if node_id == 'r':
          m.add_constraint(ct=in_count_X == 0,
                           ctname=name(node_id, var='in_count_X'))
          # terminal node
      elif data['n_lines'] > 0:
          m.add_constraint(ct=in_count_X == 1,
                           ctname=name(node_id, var='in_count_X'))
      else:
          m.add_constraint(ct=in_count_X <= 1,
                           ctname=name(node_id, var='in_count_X'))

      # 3)
      if node_id == 'r':
          m.add_constraint(ct=out_count_X >= 1,
                           ctname=name(node_id, var='out_count_X_lower'))

      # 4)
      m.add_constraint(ct=D[node_id] <= in_count_X * params['d_M'],
                       ctname="{}".format(name(node_id, var='distance_domain')))

      # 7), 8)
      if node_id != 'r':
          m.add_constraint(ct=in_count_N - out_count_N == data['n_lines'],
                           ctname="{}".format(name(node_id, var='flow_balance')))
      else:
          total_population = sum(data_['n_lines'] for _, data_ in G.nodes(data=True))
          m.add_constraint(ct=out_count_N == total_population,
                           ctname="{}".format(name(node_id, var='flow_balance')))

  logger.info('Set constraints 2, 3, 4, 7, 8')

  for i, (source, target, data) in enumerate(G.edges(data=True)):
      if i % 1000 == 0:
          print("Constraints on edge {}/{}".format(i, len(G.edges)), end='\r')

      edge_length = data['length']

      # 5)
      m.add_constraint(ct=D[target] - D[source] >= edge_length * X[source][target] - params['d_M'] * (1 - X[source][target]),
                       ctname="{}".format(name(source, target, var='distance_upper')))

      m.add_constraint(ct=D[target] - D[source] <= edge_length * X[source][target] + params['d_M'] * (1 - X[source][target]),
                       ctname="{}".format(name(source, target, var='distance_lower')))

      # 6)
      m.add_constraint(ct=N[source][target] <= params["n_M"] * X[source][target],
                       ctname="{}".format(name(source, target, var='n_max')))

  logger.info('Set constraints 5, 6')

  if m.solve() is None:
      print("Unable to solve")
      exit(1)
  else:
      # m.print_solution()
      pass

  for source, target in G.edges:
      G[source][target]['x'] = X[source][target].solution_value
      G[source][target]['n'] = N[source][target].solution_value

  for node_id in G.nodes:
      G.node[node_id]['d'] = D[node_id].solution_value

  with open(graph_path.replace('_raw.json', '_DSLAM_solution.json'), 'w') as output:
      output.write(json.dumps(json_graph.node_link_data(G)))
#+END_SRC

Plot graph resulting from optimization.

#+BEGIN_SRC python :noweb yes :var graph_path=flatten(graph_path) :tangle scripts/aachen_net/14_plot_ILP_result.py
  <<imports_&_defaults>>
  <<projection>>

  with open(graph_path + "_complete.json") as f:
      js_graph = json.load(f)

  G = json_graph.node_link_graph(js_graph)

  # get graph information
  nodes = G.nodes(data=True)

  nodes_info = []
  for id_, data in nodes:
      point = Point(data['lon'], data['lat'])

      data_ = data.copy()
      data_['geometry'] = point
      data_['id'] = id_
      data_['is_subroot'] = G['r'][id_]['x'] == 1

      nodes_info.append(data_)

  edges_info = []
  for node_id1, node_id2, data in G.edges(data=True):
      edge = LineString((
          (nodes[node_id1]['lon'], nodes[node_id1]['lat']),
          (nodes[node_id2]['lon'], nodes[node_id2]['lat'])
      ))

      data_ = data.copy()
      data_['geometry'] = edge
      data_['source'] = node_id1
      data_['target'] = node_id2

      edges_info.append(data_)

  ## provide GeoDataFrames
  nodes_df = gpd.GeoDataFrame(nodes_info)
  nodes_df.crs = {'init' :'epsg:4326'} # long-lat projection
  nodes_df = nodes_df.to_crs(projection.srs)

  edges_df = gpd.GeoDataFrame(edges_info)
  edges_df.crs = {'init' :'epsg:4326'} # long-lat projection
  edges_df = edges_df.to_crs(projection.srs)

  ## plot

  # plot params
  showroot = False

  fig = plt.figure(figsize=(6, 6), frameon=False)
  ax = fig.gca()

  # terminals
  nodes_df[(nodes_df["id"] != 'r') &
           (nodes_df["n_lines"] >= 1)].plot(ax=ax,
                                            markersize=10,
                                            color='black',
                                            zorder=1)


  nodes_df[(nodes_df["id"] != 'r') &
           (nodes_df["n_lines"] < 1)].plot(ax=ax,
                                           markersize=5,
                                           color='#a0a0a0',
                                           zorder=1)

  # highlight DSLAMS
  nodes_df[(nodes_df["id"] != 'r') &
           (nodes_df['is_subroot'])].plot(ax=ax,
                                          markersize=50,
                                          color='red',
                                          zorder=2)

  edges_df[(edges_df['x'] == 0) &
           (edges_df['source'] != 'r')].plot(ax=ax,
                                             color="#a0a0a0",
                                             linewidth=0.5,
                                             zorder=0)

  if showroot:
      nodes_df[(nodes_df["id"] == 'r')].plot(ax=ax,
                                             markersize=100,
                                             color='green',
                                             zorder=2)

      edges_df[(edges_df['source'] == 'r') &
               (edges_df['n'] >= 1)].plot(ax=ax,
                                          column='n',
                                          color="green",
                                          linewidth=0.5,
                                          zorder=0)

  edges_df[(edges_df['x'] == 1) &
           (edges_df['source'] != 'r')].plot(ax=ax,
                                             column='n',
                                             color="black",
                                             linewidth=0.5,
                                             zorder=0)

  for _, row in edges_df.iterrows():
      if row.source == 'r':
          color = 'green'
      else:
          color = 'black'

      if row.x == 0:
          continue

      if row.length != 0:
          ax.annotate(s="{0:.0f} - {0:.2f}".format(row.n, row.length),
                      xy=row.geometry.centroid.coords[0],
                      color=color,
                      zorder=5)

  for _, row in nodes_df[(nodes_df['d'] > 0)].iterrows():
      ax.annotate(s="{0:.2f}".format(row.d),
                  xy=row.geometry.centroid.coords[0],
                  color="blue",
                  zorder=5)

  plt.axis('off')
  plt.tight_layout(rect=[-0.1, -0.05, 1.1, 1])
  plt.show()
#+END_SRC

* COMMENT Local variables
# Local Variables:
# org-confirm-babel-evaluate: nil
# eval: (add-hook 'after-save-hook 'org-babel-tangle-this-file t t)
# eval: (add-hook 'org-babel-pre-tangle-hook (lambda () (org-babel-lob-ingest "utils.org")) t t)
# End:
