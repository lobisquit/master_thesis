#+PROPERTY: header-args :mkdirp yes
#+PROPERTY: header-args:python :shebang "#!/usr/bin/python \n# -*- coding: utf-8 -*-\nfrom __future__ import print_function"

* Retrieve datasets
  Download all needed files from Aachen city repository.

  These are under a special license: "Data license Germany - Attribution - Version 2.0".
  #+NAME: population_density_link
  http://offenedaten.aachen.de/dataset/81650028-ef21-4f1b-a991-9e3a3f01c729/resource/460bfe18-7df4-49fb-b5d0-6dfc1d0cffd5/download/20170630opendataaachen-daten-statistische-bezirkealle.csv

  #+NAME: district_map_link
  http://offenedaten.aachen.de/dataset/5ea893af-8f1d-4658-9066-8f05daed1022/resource/6dfc1b81-26d9-4ed8-b8c4-a61013659f51/download/statistischebezirkeaachen.zip

  #+NAME: NRW_map_link
  http://download.geofabrik.de/europe/germany/nordrhein-westfalen-latest-free.shp.zip

  For the roads details, see [[https://simonb83.github.io/making-a-map-in-matplotlib.html][here]].

  #+BEGIN_SRC bash :var population_density=population_density_link district_map=district_map_link NRW_map=NRW_map_link :results none :tangle scripts/aachen_net/01_download.sh
    mkdir -p data/aachen_net/

    # download
    wget -c $population_density -O data/aachen_net/20170630_population_density_temp.csv
    wget -c $district_map -O data/aachen_net/district_map.zip
    wget -c $NRW_map -O data/aachen_net/NRW_map.zip

    # preprocess
    awk -F, '{print $1 "," $3}' data/aachen_net/20170630_population_density_temp.csv > data/aachen_net/20170630_population_density.csv
    rm -f data/aachen_net/20170630_population_density_temp.csv

    # gather city district borders
    unzip -p data/aachen_net/district_map.zip StatistischeBezirkeAachen.shp > data/aachen_net/aachen_district_map.shp
    unzip -p data/aachen_net/district_map.zip StatistischeBezirkeAachen.shx > data/aachen_net/aachen_district_map.shx
    unzip -p data/aachen_net/district_map.zip StatistischeBezirkeAachen.dbf > data/aachen_net/aachen_district_map.dbf
    unzip -p data/aachen_net/district_map.zip StatistischeBezirkeAachen.prj > data/aachen_net/aachen_district_map.prj

    # gather NRW roads
    unzip -p data/aachen_net/NRW_map.zip gis_osm_roads_free_1.shp > data/aachen_net/NRW_roads.shp
    unzip -p data/aachen_net/NRW_map.zip gis_osm_roads_free_1.shx > data/aachen_net/NRW_roads.shx
    unzip -p data/aachen_net/NRW_map.zip gis_osm_roads_free_1.dbf > data/aachen_net/NRW_roads.dbf

    # gather NRW buildings
    unzip -p data/aachen_net/NRW_map.zip gis_osm_buildings_a_free_1.shp > data/aachen_net/NRW_buildings.shp
    unzip -p data/aachen_net/NRW_map.zip gis_osm_buildings_a_free_1.shx > data/aachen_net/NRW_buildings.shx
    unzip -p data/aachen_net/NRW_map.zip gis_osm_buildings_a_free_1.dbf > data/aachen_net/NRW_buildings.dbf
  #+END_SRC

* Create city map
  Put all relevant NRW data inside a ~postgresql~ database with ~postgis~ extension installed.
  Database is run localy as normal user inside a proper socket directory.

  See [[https://simonb83.github.io/making-a-map-in-matplotlib.html][here]] for details on moving ~shp~ to ~postgresql~.

  #+NAME: socket_dir
  - data/aachen_net/postgres/socket_dir/

  #+BEGIN_SRC bash :results none :tangle scripts/aachen_net/02_postgres_init.sh :var socket_dir=socket_dir
    # create and start local postgres session
    mkdir -p data/aachen_net/postgres/
    initdb -D data/aachen_net/postgres/

    mkdir -p $(pwd)/$socket_dir
    postgres -D data/aachen_net/postgres/ -k $(pwd)/$socket_dir &

    dropdb nrw -h $(pwd)/$socket_dir
    createdb nrw -h $(pwd)/$socket_dir
    psql nrw -c 'CREATE EXTENSION postgis' -h $(pwd)/$socket_dir

    echo "WARNING: this takes some time..."

    shp2pgsql -s 4326 data/aachen_net/NRW_roads.shp roads | psql nrw -h $(pwd)/$socket_dir > /dev/null
    shp2pgsql -s 4326 data/aachen_net/NRW_buildings.shp buildings | psql nrw -h $(pwd)/$socket_dir > /dev/null
  #+END_SRC

** Retrieve city border
   Extract the union of Aachen metropolitan area, in order to filter roads properly.

   #+BEGIN_SRC python :results none :noweb yes :tangle scripts/aachen_net/03_city_border.py
     <<imports_&_defaults>>
     <<projection>>
     <<districts>>

      with open('data/aachen_net/aachen_border.txt', 'w') as outfile:
          # extract border
          aachen_area = cascaded_union(district_map['geometry'])

          # convert back to (lat, long) for this purpose
          aachen_area = Polygon([projection(*coord[0:2], inverse=True) \
                                 for coord in aachen_area.exterior.coords])

          # convert border from 3D to 2D
          outfile.write(aachen_area.to_wkt())
   #+END_SRC

** Extract city information
   Create output ~shp~ for roads and buildings using the following queries.

   #+NAME: roads_query
   #+BEGIN_SRC sql
     SELECT osm_id, geom FROM roads
      WHERE fclass NOT IN ('trunk_link', 'bridleway', 'motorway',
                           'motorway_link', 'path', 'primary_link',
                           'secondary_link', 'service', 'steps',
                           'tertiary_link', 'track', 'track_grade2',
                           'track_grade3', 'track_grade4', 'track_grade5',
                           'unclassified', 'unknown')
        AND ST_Intersects(geom, ST_SetSRID(ST_GeomFromText('$aachen_border'), 4326));
   #+END_SRC

   #+NAME: buildings_query
   #+BEGIN_SRC sql
     SELECT osm_id, geom, type FROM buildings
      WHERE ST_Intersects(geom, ST_SetSRID(ST_GeomFromText('$aachen_border'), 4326));
   #+END_SRC

   #+BEGIN_SRC bash :noweb yes :results output :tangle scripts/aachen_net/04_extraction.sh :var socket_dir=socket_dir
     # extract roads around aachen border
     read aachen_border < data/aachen_net/aachen_border.txt

     # due to noweb shortcomings, first newline and leading whitespaces have to be removed
     query="
            <<roads_query>>"
     pgsql2shp -f data/aachen_net/aachen_roads -h $(pwd)/$socket_dir nrw \
               "$(echo ${query:1:${#query}} | sed 's/^[\t ]*//g')"

     query="
            <<buildings_query>>"
     pgsql2shp -f data/aachen_net/aachen_buildings -h $(pwd)/$socket_dir nrw \
               "$(echo ${query:1:${#query}} | sed 's/^[\t ]*//g')"
   #+END_SRC

** Plot the map
   Create final plot, with roads as well as population density.

   #+BEGIN_SRC python :results none :noweb yes :tangle scripts/aachen_net/05_plot_map.py :var valid_types=flatten(utils.org:valid_types)
     <<all_datasets>>

     fig = plt.figure(figsize=(6, 6), frameon=False)
     ax = fig.gca()

     district_map.plot(column='density',
                       cmap='viridis',
                       legend=True,
                       linewidth=0, # remove districts borders
                       alpha=0.7,
                       ax=ax)

     roads_map.plot(color='black',
                    alpha=0.6,
                    linewidth=0.15,
                    ax=ax)

     buildings_map.plot(color='black',
                        alpha=0.5,
                        linewidth=0.15,
                        ax=ax)

     # set title of colorbar (dirty trick)
     fig.get_axes()[1].set_title('    people/km²',
                                 fontweight=font_spec['font.weight'],
                                 fontsize=12)

     fig.get_axes()[1].tick_params(labelsize=10)

     plt.axis('off')
     plt.tight_layout(rect=[-1.25, -0.04, 1.2, 1])

     # plt.show()

     plt.savefig('figures/aachen_citymap.png', dpi=250)
     plt.close('all')
   #+END_SRC

* Create graph from city roads
** Create an abstract graph from the roads
   When creating the graph, remember ~OSM_ID~, in order to assign each building a proper edge.

   #+NAME: graph_path
   - data/aachen_net/aachen_graph_raw.json

   #+BEGIN_SRC python :noweb yes :var valid_types=flatten(utils.org:valid_types) :var graph_path=flatten(graph_path) :tangle scripts/aachen_net/06_get_roads_graph.py
     <<imports_&_defaults>>
     <<projection>>
     <<roads>>
     <<buildings>>

     sg = ShapeGraph(shapefile=roads_path, to_graph=True, properties=['OSM_ID'])

     # convert graph to json
     G = json_graph.node_link_data(sg.graph)

     for node in G['nodes']:
         node['lat'], node['lon'] = sg.node_xy[node['id']]

     # use of private variable seems to be mandatory here
     edge_osm_id_map = {
         edge: sg.line_info(info.line_index).props['OSM_ID']
         for edge, info in sg._edges.items() if info.line_index is not None
     }

     for edge in G['edges']:
         if edge in edge_osm_id_map:
             G[edge[0]][edge[1]]['OSM_ID'] = edge_osm_id_map[edge]

     with open(graph_path, 'w') as output:
         output.write(json.dumps(G))
   #+END_SRC

** Match each building with the closest road
   Find the closest road on the map for each house, in order to set the house as a node on the road graph.
   This has to consider only roads in the major component of the city, not the unconnected ones.

   #+NAME: closest_edges_path
   - data/aachen_net/closest_edges.csv

   #+BEGIN_SRC python :noweb yes :tangle scripts/aachen_net/07_get_closest_roads.py :var valid_types=flatten(utils.org:valid_types) :var closest_edges_path=flatten(closest_edges_path) :var graph_path=flatten(graph_path)
     <<all_datasets>>

     # load graph
     with open(graph_path) as f:
         js_graph = json.load(f)

     G = json_graph.node_link_graph(js_graph)

     # precompute {edge: map_line, ...} association
     lines = {
         (x, y): LineString([ projection(G.node[x]['lon'], G.node[x]['lat']),
                              projection(G.node[y]['lon'], G.node[y]['lat']) ])
         for x, y in G.edges()
     }

     # convert to dataframe, for convenience
     lines = gpd.GeoDataFrame.from_dict(lines, orient='index')
     lines.columns = ['geometry']
     lines.index.name = 'edge'

     # compute minimum distance between each building and the roads
     def nearest_line(building, lines_):
         # get closest edge
         edge = lines_.geometry.distance(building.geometry).idxmin()
         line = lines_.loc[[edge]].geometry.values[0]

         district_index = -1
         for index, district_row in district_map.iterrows():
             if building.geometry.centroid.within(district_row.geometry):
                 district_index = index

         # avoid adding buildings which center is outside the city
         if district_index == -1:
             return

         # print(building.geometry.to_wkt())
         _, proj_point = nearest_points(building.geometry, line)

         return pd.Series({
             'osm_id': building.OSM_ID,
             'edge0': edge[0],
             'edge1': edge[1],
             # edge (street) line
             'line': line,
             # location of new node
             'new_point': proj_point,
             # weight of new node
             'area': building.geometry.area,
             'district_index': district_index
         })

     closest_lines = []
     for index, row in buildings_map.iterrows():
         print("{}/{}".format(index, len(buildings_map)), end='\r')
         building_data = nearest_line(row, lines)
         if building_data:
             closest_lines.append(building_data)

     pd.DataFrame(closest_lines).to_csv(closest_edges_path,
                                        quoting=csv.QUOTE_NONNUMERIC,
                                        index=None)
   #+END_SRC

** Project each building on its road
   The graph is filled with buildings, replacing each edge
   with two edges, with the building node in the middle.

   Use projected point of the building on the road point as actual position:
   line is supposed to be payed by the customer from the road to the home,
   so there is no cost for the operator.

   #+BEGIN_SRC python :noweb yes :var valid_types=flatten(utils.org:valid_types) :var graph_path=flatten(graph_path) :tangle scripts/aachen_net/08_add_buildings_to_graph.py :var closest_edges_path=flatten(closest_edges_path)
     <<all_datasets>>

     # read graph G
     with open(graph_path) as f:
         js_graph = json.load(f)

     G = json_graph.node_link_graph(js_graph)

     closest_lines = pd.read_csv(closest_edges_path)

     # remove buildings that are too big or too small to be residential
     closest_lines = closest_lines[(closest_lines.area > 40) &
                                   (closest_lines.area < 2000)]

     # pick only a fraction of buildings (resindential ones): since
     # we have no info about it, we suppose "residentiality" to be iid
     closest_lines = closest_lines.sample(frac=0.6, random_state=13)

     # split evenly the population across all district (remaining) buildings
     def split_population(group):
         # retrieve current district total population (same for all the group)
         district_id = group.district_index.iloc[0]
         district_population = district_map.loc[district_id].population

         # make proportion
         group['population'] = group.area / group.area.sum() * district_population

         return group

     # assigned each building an estimation of its number of inhabitants
     closest_lines = closest_lines.groupby('district_index').apply(split_population)

     # infer number of families (internet lines)
     # from number of inhabitants per building /heuristically/
     closest_lines['n_lines'] = (closest_lines.population // 6).astype(int)
     closest_lines.loc[closest_lines['n_lines'] < 1, 'n_lines'] = 1
     closest_lines.loc[closest_lines['n_lines'] > 48, 'n_lines'] = 48

     # add new nodes, corresponding to buildings
     current_number = 0
     for _, group in closest_lines.groupby(['edge0', 'edge1']):
         edge = group['edge0'].iloc[0], group['edge1'].iloc[0]

         line = wkt.loads(group.line.iloc[0])

         # collect new point information
         new_points = []
         for _, row in group.iterrows():
             print("Added building {}/{}".format(current_number,
                                                 len(closest_lines)),
                   end="\r")

             current_number += 1

             proj_new_point = wkt.loads(row.new_point)
             new_point = Point(projection(proj_new_point.x,
                                          proj_new_point.y,
                                          inverse=True))

             if row.area > 10000:
                 print(new_point.y, new_point.x)

             new_points.append({
                 'id_':          row.osm_id,
                 'new_point':  new_point,
                 'n_lines': row.n_lines,
                 'proj':       line.project(new_point)
             })

         # sort them via projection
         new_points.sort(key=lambda x: x['proj'])

         # add all new nodes to graph
         for new_point in new_points:
             G.add_node(node_for_adding=new_point['id_'],
                        lon=new_point['new_point'].x,
                        lat=new_point['new_point'].y,
                        n_lines=new_point['n_lines'])

         # remove old edge
         G.remove_edge(*edge)

         # add new ones
         G.add_edge(edge[0], new_points[0]['id_'])

         # loop over couples of subsequent points
         for point1, point2 in zip(new_points[:-1], new_points[1:]):
             # distance will be added later (also for untouched edges)
             G.add_edge(point1['id_'], point2['id_'])

         G.add_edge(new_points[-1]['id_'], edge[1])

     ## polish the graph

     # relevant information for nodes are
     # - lat
     # - lon
     # - population (> 0 if building)
     for node_id in G.nodes:
         node = G.nodes[node_id]

         lat = node['lat']
         lon = node['lon']

         if 'n_lines' not in node:
             n_lines = 0
         else:
             n_lines = node['n_lines']

         node.clear()
         node['lat'] = lat
         node['lon'] = lon
         node['n_lines'] = n_lines

     # prune useless nodes (no building and just two neighbours)
     nodes_to_remove = []
     for node_id, data in G.nodes(data=True):
         if G.degree(node_id) == 2 and data['n_lines'] == 0:
             neighbours_ids = list(G[node_id])

             # remove previous two edges
             G.remove_edge(node_id, neighbours_ids[0])
             G.remove_edge(node_id, neighbours_ids[1])

             G.add_edge(neighbours_ids[0], neighbours_ids[1])

             nodes_to_remove.append(node_id)

         # remove terminal streets
         elif G.degree(node_id) == 1 and data['n_lines'] == 0:
             nodes_to_remove.append(node_id)

     for node_id in nodes_to_remove:
         G.remove_node(node_id)

     # remove spurious nodes not part of the main component
     main_component = sorted(nx.connected_components(G), key=len, reverse=True)[0]
     G = nx.subgraph(G, main_component)

     # relevant information for edges is only their length
     def Haversine_distance(point0, point1):
         lon1, lat1 = point0
         lon2, lat2 = point1

         # use precise measure for distance
         radius = 6371  # km

         # compute distance using Haversine formula
         dlat = math.radians(lat2 - lat1)
         dlon = math.radians(lon2 - lon1)
         a = (math.sin(dlat / 2) * math.sin(dlat / 2) +
              math.cos(math.radians(lat1)) * math.cos(math.radians(lat2)) *
              math.sin(dlon / 2) * math.sin(dlon / 2))
         c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
         d = radius * c

         # use distance in meters
         return d * 1000

     for source, target in G.edges:
         # read (and compute distance) between begin and end point
         node0 = G.nodes[source]
         node1 = G.nodes[target]

         edge_info = G.edges[(source, target)]
         edge_info.clear()

         point0 = node0['lon'], node0['lat']
         point1 = node1['lon'], node1['lat']

         edge_info['length'] = Haversine_distance(point0, point1)

     # certains ids seem to be of type numpy.int64 in edges definition!
     # better fix them: need to copy to avoid NetworkX freeze
     G_fixed = nx.Graph(G)

     for source, target, data in G.edges(data=True):
         if type(source) == np.int64 or \
            type(target) == np.int64:
             G_fixed.remove_edge(source, target)
             G_fixed.add_edge(int(source), int(target), **data)

     # select buildings stats and output
     buildings_n_lines = [data['n_lines'] for _, data in G_fixed.nodes(data=True) if data['n_lines'] > 0]
     logger.info("Extracted polished graph with {} nodes ({} buildings, {} lines) and {} edges"\
                 .format(len(G.nodes),
                         len(buildings_n_lines),
                         int(sum(buildings_n_lines)),
                         len(G.edges)))

     with open(graph_path.replace('_raw.json', '_complete.json'), 'w') as output:
         output.write(json.dumps(json_graph.node_link_data(G_fixed)))
   #+END_SRC

** Plot obtained graph on the map
   Plot final graph on top of district map.

   #+BEGIN_SRC python :noweb yes :var valid_types=flatten(utils.org:valid_types) :var graph_path=flatten(graph_path) :tangle scripts/aachen_net/09_plot_city_graph.py
     <<imports_&_defaults>>
     <<projection>>
     <<districts>>

     # read graph G
     with open(graph_path.replace('_raw.json', '_complete.json')) as f:
         js_graph = json.load(f)

     G = json_graph.node_link_graph(js_graph)

     ## "convert" graph to GeoDataFrame

     # collect data into proper lists
     nodes = G.nodes(data=True)

     nodes_info = []
     for id_, data in nodes:
         point = Point(data['lon'], data['lat'])
         nodes_info.append({'geometry': point, **data})

     edges_info = []
     for node_id1, node_id2, data in G.edges(data=True):
         edge = LineString((
             (nodes[node_id1]['lon'], nodes[node_id1]['lat']),
             (nodes[node_id2]['lon'], nodes[node_id2]['lat'])
         ))

         edges_info.append({'geometry': edge, **data})

     ## provide GeoDataFrames
     nodes_df = gpd.GeoDataFrame(nodes_info)
     nodes_df.crs = {'init' :'epsg:4326'} # long-lat projection
     nodes_df = nodes_df.to_crs(projection.srs)

     edges_df = gpd.GeoDataFrame(edges_info)
     edges_df.crs = {'init' :'epsg:4326'} # long-lat projection
     edges_df = edges_df.to_crs(projection.srs)

     ## plot everything
     fig = plt.figure(figsize=(6, 6), frameon=False)
     ax = fig.gca()

     ax.set_title("Detail of extracted city graph\n",
                  fontsize=15,
                  fontweight=font_spec['font.weight'])

     # plot just city external border
     aachen_border = cascaded_union(district_map.geometry)
     gpd.GeoDataFrame({'geometry': [aachen_border]}).plot(color='white',
                                                          edgecolor='black',
                                                          linewidth=0.5,
                                                          ax=ax)

     nodes_df.plot(ax=ax,
                   markersize=1,
                   color='black',
                   zorder=2)

     edges_df.plot(ax=ax,
                   color='grey',
                   linewidth=0.5,
                   zorder=1)

     plt.axis('off')

     # cut a window for better visualization
     ax.set_xlim(293117, 295351)
     ax.set_ylim(5627800, 5629570)
     plt.tight_layout(rect=[-0.11, 0, 1, 1])

     # plt.show()

     plt.savefig('figures/aachen_city_graph.png', dpi=250)
     plt.close('all')
   #+END_SRC

* Solve associated ILP problem

  $c_r$, cost per sub-root node has to consider also the cable to reach the first level router.
  We estimate 1000€ for the DSLAM and 4000€ for the mentioned connection.

  See [[https://www.itscosts.its.dot.gov][here]] for pricing. TODO cite as a source

  #+NAME: model_params
  | $n_M$ [unit]   |   50 |
  | $d_M$ [m]      | 1500 |
  | $c_r$ [€/unit] | 5000 |
  | $c_f$ [€/m]    |    3 |
  | $c_c$ [€/m]    |    1 |
  | $c_e$ [€/m]    |   50 |

  #+BEGIN_SRC python :noweb yes :var graph_path=flatten(graph_path) :var model_params=model_params :tangle scripts/aachen_net/10_ILP.py
    <<imports_&_defaults>>
    <<projection>>

    from docplex.mp.model import Model
    import cplex

    cplex_engine = cplex.Cplex()
    cplex_engine.parameters.mip.display.set(5)
    cplex_engine.parameters.mip.interval.set(-1)

    ##############################
    # Load and pre-process graph #
    ##############################

    with open(graph_path.replace('_raw.json', '_complete.json')) as f:
        js_graph = json.load(f)

    G = json_graph.node_link_graph(js_graph)
    assert nx.is_connected(G)

    G = G.to_directed()

    # add artificial root node to G, with a zero-length arc for all the nodes
    G.add_node('r', n_lines=0, lat=0, lon=0)

    for node_id in G.nodes:
        # TODO check if node is in R (candidate sub-roots)
        G.add_edge('r', node_id, length=0)

    ####################
    # Model parameters #
    ####################
    params = { param[1:4]: value
               for param, value in model_params
               if param != "Parameter" }

    ###################
    # Setup variables #
    ###################

    m = Model(log_output=True)

    def name(source, target=None, var='x'):
        if target:
            return "{}_{}~{}".format(var, source, target)
        else:
            return "{}_{}".format(var, source)

    X = {}
    N = {}
    for i, (source, target) in enumerate(G.edges):
        if i % 10000 == 0:
            print("Initializing edge {}/{}".format(i, len(G.edges)), end='\r')

        if source not in X:
            X[source] = {}

        if source not in N:
            N[source] = {}

        ## active edge indicator
        X[source][target] = m.binary_var(name=name(source, target, var='x'))
        N[source][target] = m.continuous_var(name=name(source, target, var='n'))
        m.add_constraint(ct=N[source][target] >= 0,
                         ctname="{} >= 0".format(name(source, target, var='n')))

    D = {}
    for i, (node_id, data) in enumerate(G.nodes(data=True)):
        if i % 10000 == 0:
            print("Initializing node {}/{}".format(i, len(G.nodes)), end='\r')

        ## set distance counter
        D[node_id] = m.continuous_var(name=name(node_id, var='d'))
        m.add_constraint(ct=D[node_id] >= 0,
                         ctname="{} >= 0".format(name(source, target, var='d')))

    logger.info('Initialized variables')

    ######################
    # Objective function #
    ######################

    obj_func = 0

    # A), B) ~> suppose full-fiber for now
    for node_id in G.nodes():
        obj_func += D[node_id] * params['c_f']

    # C)
    for source, target, data in G.edges(data=True):
        obj_func += X[source][target] * data['length'] * params['c_e']

    # D)
    for _, target in G.out_edges('r'):
        obj_func += X['r'][target] * params['c_r']

    m.set_objective('min', obj_func)

    logger.info('Initialized objective function')

    ###############
    # Constraints #
    ###############

    for i, (node_id, data) in enumerate(G.nodes(data=True)):
        if i % 1000 == 0:
            print("Constraints on node {}/{}".format(i, len(G.nodes)), end='\r')

        in_count_X = 0
        in_count_N = 0
        for source, target in G.in_edges(node_id):
            in_count_X += X[source][target]
            in_count_N += N[source][target]

        out_count_X = 0
        out_count_N = 0
        for source, target in G.out_edges(node_id):
            out_count_X += X[source][target]
            out_count_N += N[source][target]

        # 2)
        if node_id == 'r':
            m.add_constraint(ct=in_count_X == 0,
                             ctname=name(node_id, var='in_count_X'))
            # terminal node
        elif data['n_lines'] > 0:
            m.add_constraint(ct=in_count_X == 1,
                             ctname=name(node_id, var='in_count_X'))
        else:
            m.add_constraint(ct=in_count_X <= 1,
                             ctname=name(node_id, var='in_count_X'))

        # 3)
        if node_id == 'r':
            m.add_constraint(ct=out_count_X >= 1,
                             ctname=name(node_id, var='out_count_X_lower'))

        # 4)
        m.add_constraint(ct=D[node_id] <= in_count_X * params['d_M'],
                         ctname="{}".format(name(node_id, var='distance_domain')))

        # 7), 8)
        if node_id != 'r':
            m.add_constraint(ct=in_count_N - out_count_N == data['n_lines'],
                             ctname="{}".format(name(node_id, var='flow_balance')))
        else:
            total_population = sum([_data['n_lines'] for _, _data in G.nodes(data=True)])
            m.add_constraint(ct=out_count_N == total_population,
                             ctname="{}".format(name(node_id, var='flow_balance')))

    logger.info('Set constraints 2, 3, 4, 7, 8')

    for i, (source, target, data) in enumerate(G.edges(data=True)):
        if i % 1000 == 0:
            print("Constraints on edge {}/{}".format(i, len(G.edges)), end='\r')

        edge_length = data['length']

        # 5)
        m.add_constraint(ct=D[target] - D[source] >= edge_length * X[source][target] - params['d_M'] * (1 - X[source][target]),
                         ctname="{}".format(name(source, target, var='distance_upper')))

        m.add_constraint(ct=D[target] - D[source] <= edge_length * X[source][target] + params['d_M'] * (1 - X[source][target]),
                         ctname="{}".format(name(source, target, var='distance_lower')))
        # 6)
        m.add_constraint(ct=N[source][target] <= n_M * N[source][target],
                         ctname="{}".format(name(source, target, var='n_max')))

    logger.info('Set constraints 5')

    if m.solve() is None:
        print("Unable to solve")
        exit(1)
    else:
        # m.print_solution()
        pass

    for source, target in G.edges:
        G[source][target]['x'] = X[source][target].solution_value
        G[source][target]['n'] = N[source][target].solution_value

    for node_id in G.nodes:
        G.node[node_id]['d'] = D[node_id].solution_value

    with open(graph_path.replace('_raw.json', '_DSLAM_solution.json'), 'w') as output:
        output.write(json.dumps(json_graph.node_link_data(G)))
  #+END_SRC

  Plot graph resulting from optimization.

  #+BEGIN_SRC python :noweb yes :var graph_path=flatten(graph_path) :tangle scripts/aachen_net/11_plot_ILP_result.py
    <<imports_&_defaults>>
    <<projection>>

    with open(graph_path.replace('_raw.json', '_DSLAM_solution.json')) as f:
        js_graph = json.load(f)

    G = json_graph.node_link_graph(js_graph)

    # get graph information
    nodes = G.nodes(data=True)

    nodes_info = []
    for id_, data in nodes:
        point = Point(data['lon'], data['lat'])

        data_ = data.copy()
        data_['geometry'] = point
        data_['id'] = id_
        data_['is_subroot'] = ('r', id_) in G.in_edges(id_)

        nodes_info.append(data_)

    edges_info = []
    for node_id1, node_id2, data in G.edges(data=True):
        edge = LineString((
            (nodes[node_id1]['lon'], nodes[node_id1]['lat']),
            (nodes[node_id2]['lon'], nodes[node_id2]['lat'])
        ))

        data_ = data.copy()
        data_['geometry'] = edge
        data_['source'] = node_id1
        data_['target'] = node_id2

        edges_info.append(data_)

    ## provide GeoDataFrames
    nodes_df = gpd.GeoDataFrame(nodes_info)
    nodes_df.crs = {'init' :'epsg:4326'} # long-lat projection
    nodes_df = nodes_df.to_crs(projection.srs)

    edges_df = gpd.GeoDataFrame(edges_info)
    edges_df.crs = {'init' :'epsg:4326'} # long-lat projection
    edges_df = edges_df.to_crs(projection.srs)

    ## plot
    fig = plt.figure(figsize=(6, 6), frameon=False)
    ax = fig.gca()

    nodes_df[nodes_df["id"] != 'r'].plot(ax=ax,
                                         markersize=1,
                                         color='black',
                                         zorder=1)

    # highlight DSLAMS
    nodes_df[(nodes_df["id"] != 'r') & (nodes_df['is_subroot'])].plot(ax=ax,
                                                                      markersize=1.5,
                                                                      color='red',
                                                                      zorder=2)

    edges_df[(edges_df['x'] == 0) & (edges_df['source'] != 'r')].plot(ax=ax,
                                                                      column='n',
                                                                      color="#a0a0a0",
                                                                      linewidth=0.5,
                                                                      zorder=0)

    edges_df[(edges_df['x'] == 1) & (edges_df['source'] != 'r')].plot(ax=ax,
                                                                      column='n',
                                                                      color="black",
                                                                      linewidth=0.5,
                                                                      zorder=0)

    plt.axis('off')
    plt.tight_layout(rect=[-0.1, -0.05, 1.1, 1])
    plt.show()
  #+END_SRC

* COMMENT Local variables
  # Local Variables:
  # org-confirm-babel-evaluate: nil
  # eval: (add-hook 'before-save-hook (lambda () (indent-region (point-min) (point-max) nil)) t t)
  # eval: (add-hook 'after-save-hook 'org-babel-tangle-this-file t t)
  # eval: (add-hook 'org-babel-pre-tangle-hook (lambda () (org-babel-lob-ingest "utils.org")) t t)
  # End:
